// This is part of the documentation usually pulled in from Spring Data Commons
:springVersion: 5.2.0.RELEASE
:spring-framework-docs: https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference
:spring-framework-javadoc: https://docs.spring.io/spring/docs/{springVersion}/javadoc-api
[[projections]]
= Projections

Spring Data query methods usually return one or multiple instances of the aggregate root managed by the repository.
However, it might sometimes be desirable to create projections based on certain attributes of those types.
Spring Data allows modeling dedicated return types, to more selectively retrieve partial views of the managed aggregates.

Imagine a repository and aggregate root type such as the following example:

.A sample aggregate and repository
====
[source, java, subs="+attributes"]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/Person.java[tag=projection.entity]

include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/Person.java[tags=projection.repository;projection.repository.concrete;!projection.repository.interface]
----
====

Now imagine that we want to retrieve the person's name attributes only.
What means does Spring Data offer to achieve this?
The rest of this chapter answers that question.

[[projections.interfaces]]
== Interface-based Projections

The easiest way to limit the result of the queries to only the name attributes is by declaring an interface that exposes accessor methods for the properties to be read, as shown in the following example:

.A projection interface to retrieve a subset of attributes
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface;!projection.interface.default-method;!projection.interface.open-projection;!projection.interface.bean-access;!projection.interface.method-parameters]
----
====

The important bit here is that the properties defined here exactly match properties in the aggregate root.
Doing so lets a query method be added as follows:

.A repository using an interface based projection with a query method
====
[source, java, subs="+attributes"]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/Person.java[tags=projection.repository;projection.repository.interface;!projection.repository.concrete]
----
====

The query execution engine creates proxy instances of that interface at runtime for each element returned and forwards calls to the exposed methods to the target object.

[[projections.interfaces.nested]]
Projections can be used recursively.
If you want to include some of the `Address` information as well, create a projection interface for that and return that interface from the declaration of `getAddress()`, as shown in the following example:

.A projection interface to retrieve a subset of attributes
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/PersonSummary.java[tag=projection.interface.nested]
----
====

On method invocation, the `address` property of the target instance is obtained and wrapped into a projecting proxy in turn.

[[projections.interfaces.closed]]
=== Closed Projections

A projection interface whose accessor methods all match properties of the target aggregate is considered to be a closed projection.
The following example (which we used earlier in this chapter, too) is a closed projection:

.A closed projection
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface;!projection.interface.default-method;!projection.interface.open-projection;!projection.interface.bean-access;!projection.interface.method-parameters]
----
====

If you use a closed projection, Spring Data can optimize the query execution, because we know about all the attributes that are needed to back the projection proxy.
For more details on that, see the module-specific part of the reference documentation.

[[projections.interfaces.open]]
=== Open Projections

Accessor methods in projection interfaces can also be used to compute new values by using the `@Value` annotation, as shown in the following example:

[[projections.interfaces.open.simple]]
.An Open Projection
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface;!projection.interface.default-method;!projection.interface.closed-projection;!projection.interface.bean-access;!projection.interface.method-parameters]
----
====

The aggregate root backing the projection is available in the `target` variable.
A projection interface using `@Value` is an open projection.
Spring Data cannot apply query execution optimizations in this case, because the SpEL expression could use any attribute of the aggregate root.

The expressions used in `@Value` should not be too complex -- you want to avoid programming in `String` variables.
For very simple expressions, one option might be to resort to default methods (introduced in Java 8), as shown in the following example:

[[projections.interfaces.open.default]]
.A projection interface using a default method for custom logic
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface;!projection.interface.open-projection]
----
====

This approach requires you to be able to implement logic purely based on the other accessor methods exposed on the projection interface.
A second, more flexible, option is to implement the custom logic in a Spring bean and then invoke that from the SpEL expression, as shown in the following example:

[[projections.interfaces.open.bean-reference]]
.Sample Person object
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface.bean-access;projection.interface;!projection.interface.open-projection;!projection.interface.closed-projection;!projection.interface.default-method;!projection.interface.method-parameters]
----
====

Notice how the SpEL expression refers to `nameBean` and invokes the `getFullName(â€¦)` method and forwards the projection target as a method parameter.
Methods backed by SpEL expression evaluation can also use method parameters, which can then be referred to from the expression.
The method parameters are available through an `Object` array named `args`. The following example shows how to get a method parameter from the `args` array:

.Sample Person object
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnly.java[tags=projection.interface;!projection.interface.open-projection;!projection.interface.closed-projection;!projection.interface.default-method;!projection.interface.bean-access]
----
====

Again, for more complex expressions, you should use a Spring bean and let the expression invoke a method, as described  <<projections.interfaces.open.bean-reference,earlier>>.

[[projections.dtos]]
== Class-based Projections (DTOs)

Another way of defining projections is by using value type DTOs (Data Transfer Objects) that hold properties for the fields that are supposed to be retrieved.
These DTO types can be used in exactly the same way projection interfaces are used, except that no proxying happens and no nested projections can be applied.

If the store optimizes the query execution by limiting the fields to be loaded, the fields to be loaded are determined from the parameter names of the constructor that is exposed.

The following example shows a projecting DTO:

.A projecting DTO
====
[source, java]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/NamesOnlyDto.java[tags=projection.class]
----
====

[[projection.dynamic]]
== Dynamic Projections

So far, we have used the projection type as the return type or element type of a collection.
However, you might want to select the type to be used at invocation time (which makes it dynamic).
To apply dynamic projections, use a query method such as the one shown in the following example:

.A repository using a dynamic projection parameter
====
[source, java, subs="+attributes"]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/Person.java[tags=projection.dynamic-projection-repository]
----
====

This way, the method can be used to obtain the aggregates as is or with a projection applied, as shown in the following example:

.Using a repository with dynamic projections
====
[source, java, subs="+attributes"]
----
include::../../examples/docs/src/test/java/org/neo4j/doc/springframework/data/docs/repositories/projection/Person.java[tags=projection.dynamic-projection-usage]
----
====
