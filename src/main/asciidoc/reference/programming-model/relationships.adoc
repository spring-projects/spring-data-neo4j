[[reference_programming-model_relationships]]
= Relating Node Entities

Since relationships are first-class citizens in Neo4j, associations between node entities are represented by relationships. 
In general, relationships are categorised by a type, and start and end nodes (which imply the direction of the relationship). 
Relationships can have an arbitrary number of properties. 
Spring Data Neo4j has special support to represent Neo4j relationships as entities too, but it is often not needed.

== @Relationship: Connecting node entities

Every field of an entity that references one or more other node entities is backed by relationships in the graph.
These relationships are managed by Spring Data Neo4j automatically.

The simplest kind of relationship is a single object reference pointing to another entity (1:1).
In this case, the reference does not have to be annotated at all, although the annotation may be used to control the direction and type of the relationship.
When setting the reference, a relationship is created when the entity is persisted.
If the field is set to `null`, the relationship is removed.

.Single relationship field
[source,java]
----
@NodeEntity
public class Movie {
    ...
    private Actor topActor;
}
----

It is also possible to have fields that reference a set of entities (1:N).
These fields come in two forms, modifiable or read-only. 
Modifiable fields are of the type `Collection<T>`, and read-only fields are `Iterable<T>`, where T is a type annotated with `@NodeEntity`.

.Node entity with relationships
[source,java]
----
@NodeEntity
public class Actor {
    ...
    @Relationship(type = "TOP_ACTOR", direction = Relationship.INCOMING)
    private Set<Movie> topActorIn;

    @Relationship(type = "ACTS_IN")
    private Set<Movie> movies;
}
----

For graph to object mapping, the automatic transitive loading of related entities depends on the depth of the horizon specified on the call to `Session.load()`.  
By default, the _related_ node or relationship entities will just be loaded to minimum depth 0, which means their properties will be set but no further related entities will be populated.

If this `Set` of related entities is modified, the changes are reflected in the graph once the root object (`Actor`, in this case) is saved. 
Relationships are added, removed or updated according to the differences between the root object that was loaded and the corresponding one that was saved..

Spring Data Neo4j ensures by default that there is only one relationship of a given type between any two given entities.
The exception to this rule is when a relationship is specified as either `OUTGOING` or `INCOMING` between two entities of the same type.
In this case, it is possible to have two relationships of the given type between the two entities, one relationship in either direction.

If you don't care about the direction then you can specify `direction=Relationship.UNDIRECTED` which will guarantee that the path between two node entities is navigable from either side.

For example, consider the `PARTNER_OF` relationship between two companies, where `(A)-[:PARTNER_OF]->(B)` implies `(B)-[:PARTNER_OF]->(A)`.
The direction of the relationship does not matter; only the fact that a `PARTNER_OF` relationship exists between these two companies is of importance.
Hence an `UNDIRECTED` relationship is the correct choice, ensuring that there is only one relationship of this type between two partners and navigating between them from either entity is possible.

[NOTE]
====
The direction attribute on a `@Relationship` defaults to `OUTGOING`. Any fields or methods backed by an `INCOMING` relationship must be explicitly annotated with an `INCOMING` direction.
====


== @RelationshipEntity: Rich Relationships

To access the full data model of graph relationships, POJOs can also be annotated with `@RelationshipEntity`, making them relationship entities. 
Just as node entities represent nodes in the graph, relationship entities represent relationships. Such POJOs allow you access and manage properties on the underlying relationships in the graph.

Fields in relationship entities are similar to node entities, in that they're persisted as properties on the relationship. 
For accessing the two endpoints of the relationship, two special annotations are available: `@StartNode` and `@EndNode`. 
A field annotated with one of these annotations will provide access to the corresponding endpoint, depending on the chosen annotation.

For controlling the relationship-type a `String` attribute called `type` is available on the `@RelationshipEntity` annotation.  
Currently, the `type` must always be specified on the `@RelationshipEntity` annotation.

[NOTE]
====
You must include `@RelationshipEntity` plus exactly one `@StartNode` field and one `@EndNode` field on your relationship entity classes or the OGM will throw a MappingException when reading or writing.  
It is not possible to use relationship entities in a non-annotated domain model.
====

.A simple Relationship entity
[source,java]
----
@NodeEntity
public class Actor {
    Long id;
    private Role playedIn;
}

@RelationshipEntity(type="PLAYED_IN")
public class Role {
    @GraphId   private Long relationshipId;
    @Property  private String title;
    @StartNode private Actor actor;
    @EndNode   private Movie movie;
}

@NodeEntity
public class Movie {
    private Long id;
    private String title;
}
----

Note that the `Actor` also contains a reference to a `Role`.  This is important for persistence, *even when saving the `Role` directly*, because paths in the graph are written starting with nodes first and then relationships are created between them.
Therefore, you need to structure your domain models so that relationship entities are reachable from node entities for this to work correctly.

Additionally, SDN4 will not persist a relationship entity that doesn't have any properties defined.  If you don't want to include properties in your relationship entity then you should use a plain `@Relationship` instead.
Multiple relationship entities which have the same property values and relate the same nodes are indistinguishable from each other and are represented as a single relationship by SDN 4.

In previous versions of Spring Data Neo4j, a dynamic relationship type field was supported.  
However, this has been dropped completely for version 4, since it was not possible to manage it effectively for both reading from and writing to the graph.

[NOTE]
====
The `@RelationshipEntity` annotation must appear on all leaf subclasses if they are part of a class hierarchy representing relationship entities.
This annotation is optional on superclasses.
====

[[reference_programming_model_relationships_relationshiptypediscrimination]]
== Discriminating Relationships Based on End Node Type

In some cases, you want to model two different aspects of a conceptual relationship using the same relationship type.
Here is a canonical example:

.Clashing Relationship Type
[source,java]
----
@NodeEntity
class Person {
    private Long id;
    @Relationship(type="OWNS")
    private Car car;

    @Relationship(type="OWNS")
    private Pet pet;
...
}
----

In previous versions of Spring Data Neo4j, you would have to add an `enforceTargetType` attribute into every clashing
`@Relationship` annotation for this to map correctly.  
Thanks to changes in the underlying object-graph mapping mechanism, this is no longer necessary and the above will work just fine.

However, please be aware that this will only work because the end node types (Car and Pet) are different types.
If you wanted a person to own two cars, for example, then you'd have to use a `Collection` of cars or use differently-named relationship types.
