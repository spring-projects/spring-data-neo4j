<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<section id="reference:programming_model:relationships">
    <title>Relating node entities</title>
    <para>
        Since relationships are first-class citizens in Neo4j, associations between node entities are represented
        by relationships. In general, relationships are categorized by a type, and start and end nodes (which
        imply the direction of the relationship). Relationships can have an arbitrary number of properties.
        Spring Data Graph has special support to represent Neo4j relationships as entities too, but it is often
        not needed.
    </para>
    <section id="reference:programming_model:relationships:relatedto">
        <title>@RelatedTo: Connecting node entities</title>
        <para>
            Every field of a node entity that references one or more other node entities is backed by relationships
            in the graph. These relationships are managed by Spring Data Graph automatically.
        </para>
        <para>
            The simplest kind of relationship is a single field pointing to another node entity (1:1).
            In this case, the field does not have to be annotated at all, although the annotation may be
            used to control the direction and type of the relationship. When setting the field, a
            relationship is created. If the field is set to <code>null</code>, the relationship is removed.
        </para>

        <example>
            <title>Single relationship field</title>
            <programlisting language="java"><![CDATA[@NodeEntity
public class Movie {
    private Actor mostPaidActor;
}
]]></programlisting>
        </example>

        <para>
            It is also possible to have fields that reference a set of node entities (1:N). These fields come in
            two forms, modifiable or read-only. Modifiable fields are of the type <code>java.util.Set&lt;T></code>,
            and read-only fields are <code>java.lang.Iterable&lt;T></code>, where T is a @NodeEntity-annotated
            class. The Java implementation of generics uses type erasure, meaning that the type parameters are
            typically not available at runtime. Therefore, the <code>elementClass</code> attribute must be
            specified on the annotation, which must always be present for 1:N fields.
        </para>
        <example>
            <title>Node entity with relationships</title>
            <programlisting language="java"><![CDATA[@NodeEntity
public class Actor {
    @RelatedTo(type = "mostPaidActor", direction = Direction.INCOMING,
            elementClass = Movie.class)
    private Set<Movie> mostPaidIn;

    @RelatedTo(type = "ACTS_IN", elementClass = Movie.class)
    private Set<Movie> movies;
}
]]></programlisting>
        </example>
        <para>
            Fields referencing other entities should not be manually initialized, as they are managed by
            Spring Data Graph under the hood. 1:N fields can be accessed immediately, and Spring Data Graph
            will provide a java.util.Set representing the relationships. If the returned set is modified,
            the changes are reflected in the graph. Spring Data Graph also ensures that there is only one
            relationship of a given type between any two given entities.
        </para>
        <note>
            By setting direction to BOTH, relationships are created in the outgoing direction, but when the
            1:N field is read, it will include relationships in both directions. A cardinality of M:N is
            not necessary because relationships can be navigated in both directions.
        </note>
        <para>
            The relationships can also be accessed by using the aspect-introduced methods
            <code>entity.getRelationshipTo(target, type)</code> and
            <code>entity.relateTo(target, type)</code> available on each NodeEntity.
            These methods find and create Neo4j relationships. It is also possible to manually remove
            relationships by using <code>entity.removeRelationshipTo(target, type)</code>.
            Using these methods is rarely necessary though.
        </para>
    </section>

    <section>
        <title>@RelationshipEntity: Rich relationships</title>
        <para>
            To access the full data model of graph relationships, POJOs can also be annotated with
            <code>@RelationshipEntity</code>, making them relationship entities. Just as node entities represent
            nodes in the graph, relationship entities represent relationships. As described above,
            fields annotated with <code>@RelatedTo</code> provide a way to link node entities together
            via relationships, but it provides no way of accessing the relationships themselves.
        </para>
        <para>
            Relationship entities cannot be instantiated directly but are rather created via
            node entities, either by @RelatedToVia-annotated fields
            (see <xref linkend="reference:programming_model:relationships:relatedtovia"/>),
            or by the introduced
            <code>entity.relateTo(target, relationshipClass, type)</code> and
            <code>entity.getRelationshipTo(target, relationshipClass, type)</code> methods
            (see <xref linkend="reference:programming-model:introduced-methods"/>).
        </para>
        <para>
            Fields in relationship entities are, similarly to node entities, persisted as properties on
            the relationship. For accessing the two endpoints of the relationship, two special annotations
            are available: <code>@StartNode</code> and <code>@EndNode</code>. A field annotated with
            one of these annotations will provide read-only access to the corresponding endpoint, depending
            on the chosen annotation.
        </para>
        <example>
            <title>Relationship entity</title>
            <programlisting language="java"><![CDATA[@NodeEntity
public class Actor {
    public Role playedIn(Movie movie, String title) {
        return relatedTo(movie, Role.class, "ACTS_IN");
    }
}

@RelationshipEntity
public class Role {
    String title;

    @StartNode private Actor actor;
    @EndNode private Movie movie;
}
        ]]></programlisting>

        </example>
    </section>
    <section id="reference:programming_model:relationships:relatedtovia">
        <title>@RelatedToVia: Accessing relationship entities</title>
        <para>
            To provide easy programmatic access to the richer relationship entities of the data model,
            the annotation <code>@RelatedToVia</code> can be added on fields of type
            <code>java.lang.Iterable&lt;T></code>, where T is a <code>@RelationshipEntity</code>-annotated
            class. These fields provide read-only access to relationship entities.
        </para>
        <example>
            <title>Accessing relationship entities using @RelatedToVia</title>
            <programlisting language="java"><![CDATA[@NodeEntity
public class Actor {
    @RelatedToVia(type = "ACTS_IN", elementClass = Role.class)
    private Iterable<Role> roles;

    public Role playedIn(Movie movie, String title) {
        Role role = relateTo(movie, Role.class, "ACTS_IN");
        role.setTitle(title);
        return role;
    }
}
]]></programlisting>
        </example>
    </section>
</section>