== Neo4jClient

Spring Data Neo4j⚡️RX comes with a Neo4j Client, providing a human readable layer on top of Neo4js Java driver.
It has the following main goals

0. Integrate into Springs transaction management, for both imperative and reactive scenarios
0. Participate in JTA-Transactions if necessary
0. Provide a consistent API for both imperative and reactive scenarios
0. Don't add any mapping overhead

SDN-RX relies on all those features and uses them to fulfill it's entity mapping features.

The https://github.com/neo4j/neo4j-java-driver[plain java driver] is a very versatile tool
and provides an asynchronous API in addition to the imperative and reactive versions.
SDN-RX uses it as directly as possible while being as user friendly and idiomatic as possible, too.

The Neo4j Client comes in two flavors:

* `org.springframework.data.neo4j.core.Neo4jClient`
* `org.springframework.data.neo4j.core.ReactiveNeo4jClient`

While both versions provide an API using the same vocabulary and syntax, they are not API compatible.
Both versions feature the same, fluent API to specify queries, bind parameters and extract results.

=== Imperative or reactive?

Interactions with a Neo4j client usually ends with a call to

* `fetch().one()`
* `fetch().first()`
* `fetch().all()`
* `run()`

The imperative version will interact at this moment with the database
and get the requested results or summary, wrapped in a `Optional<>` or a `Collection`.

The reactive version will in contrast return a publisher of the requested type.
Interaction with the database and retrieval of the results will not happen until the publisher is subscribed to.
The publisher can only be subscribed once.

=== Getting an instance of the client

As with most things in SDN-RX, both clients depend on a configured driver instance.

[[neo4j-client-create-imperative-client]]
[source,java]
.Creating an instance of the imperative Neo4j client
----
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import org.org.springframework.data.neo4j.core.Neo4jClient;

public class Demo

    public static void main(String...args) {

        Driver driver = GraphDatabase
            .driver("neo4j://localhost:7687", AuthTokens.basic("neo4j", "password");

        Neo4jClient client = Neo4jClient.create(driver);
    }
}
----

The driver can only open a reactive session against a 4.0 database and will fail with an exception on any lower version.

[[neo4j-client-create-reactive-client]]
[source,java]
.Creating an instance of the reactive Neo4j client
----
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

import org.org.springframework.data.neo4j.core.ReactiveNeo4jClient;

public class Demo

    public static void main(String...args) {

        Driver driver = GraphDatabase
            .driver("neo4j://localhost:7687", AuthTokens.basic("neo4j", "password");

        ReactiveNeo4jClient client = ReactiveNeo4jClient.create(driver);
    }
}
----

NOTE: Make sure you use the same driver instance for the client as you used for providing a `Neo4jTransactionManager` or `ReactiveNeo4jTransactionManager`
in case you have enabled transactions.
The client won't be able to synchronize transactions if you use another instance of a driver.

Our Spring Boot starter provides ready to use beans of the Neo4j client that fit the environment (imperative or reactive)
and you usually don't have to configure your own instance.

=== Usage

[[neo4j-client-selecting-the-target-database]]
==== Selecting the target database

The Neo4j client is well prepared to be used with the multidatabase features of Neo4j 4.0.
The client uses the default database unless you specify otherwise.
The fluent API of the client allows to specify the target database exactly once, after the declaration of the query to execute.
<<neo4j-client-reactive-selecting-the-target-database>> demonstrates it with the reactive client:

[[neo4j-client-reactive-selecting-the-target-database]]
[source,java]
.Selecting the target database
----
Flux<Map<String, Object>> allUsers = client
	.newQuery("MATCH (u:User) RETURN u")
	.in("userDatabase") // <1>
	.fetch()
	.all();
----
<1> Select the target database in which the query is to be executed

==== Specifying queries

The interaction with the clients starts with a query.
A query can be defined by a plain `String` or a `Supplier<String>`.
The supplier will be evaluated as late as possible and can be provided by any query builder.

[[neo4j-client-specifying-queries]]
[source,java]
.Specifiying a query
----
Mono<Map<String, Object>> firstUser = client
	.newQuery(() -> "MATCH (u:User) RETURN u")
	.fetch()
	.first();
----

==== Retrieving results

As the previous listings shows, the interaction with the client always ends with a call to `fetch` and how many results shall be received.
Both reactive and imperative client offer

`one()`:: Expect exactly one result from the query
`first()`:: Expect results and return the first record
`all()``:: Retrieve all records returned

The imperative client returns `Optional<T>` and `Collection<T>` respectively,
while the reactive client returns `Mono<T>` and `Flux<T>`, the later one being executed only when subscribed to.

If you don't expect any results from your query, than use `run()` after specificity the query.

[[neo4j-client-reactive-get-result-summaries]]
[source,java]
.Retrieving result summaries in a reactive way
----
Mono<ResultSummary> summary = reactiveClient
    .newQuery("MATCH (n:Unused) DELETE n")
    .run();

summary
    .map(ResultSummary::counters)
    .subscribe(counters ->
        System.out.println(counters.nodesDeleted() + " nodes have been deleted")
    ); // <1>
----
<1> Only here the query is triggered

Please take a moment to compare both listings and understand the difference when the actual query is triggered.

[[neo4j-client-imperative-get-result-summaries]]
[source,java]
.Retrieving result summaries in a imperative way
----
Optional<ResultSummary> optionalSummary = imperativeClient
    .newQuery("MATCH (n:Unused) DELETE n")
    .run(); // <1>

optionalSummary
    .map(ResultSummary::counters)
    .ifPresent(counters ->
        System.out.println(counters.nodesDeleted() + " nodes have been deleted")
    );
----
<1> Here the query is triggered immediate

==== Mapping parameters

Queries can contain named parameters (`$someName`).
The Neo4j client allows comfortable binding to those.

NOTE: The client doesn't check whether all parameters are bound or whether there are to many values.
That is left to the driver.
However the client prevents you from using a parameter name twice.

You can either map simple types that the Java driver understands or complex classes.
Please have a look at the https://neo4j.com/docs/driver-manual/current/cypher-values/#driver-neo4j-type-system[drivers manual], to see which simple types are understood.

[[neo4j-client-mapping-simple-types]]
[source,java]
.Mapping simple types
----
Map<String, Object> parameters = new HashMap<>();
parameters.put("bikeName", "M.*");
parameters.put("location", "Sweden");

Flux<Map<String, Object>> usedBikes = client
    .newQuery(
        "MATCH (o:User {name: $name}) - [:OWNS] -> (b:Bike) - [:USED_ON] -> (t:Trip) " +
        "WHERE t.takenOn > $aDate " +
        "  AND b.name =~ $bikeName " +
        "  AND t.location = $location " +
        "RETURN b"
    )
    .bind("michael").to("name") // <1>
    .bind(LocalDate.of(2019, 1, 1)).to("aDate")
    .bindAll(parameters) // <2>
    .fetch()
    .all();
----
<1> There's a fluent API for binding simple types
<2> Alternatively parameters can be bound via a map of named parameters

SDN-RX does a lot of complex mapping and it uses the same API that you can use from the client.

You can provide a `Function<T, Map<String, Object>>` for any given domain object like an owner of bicycles in <<neo4j-client-domain-example>>
to the Neo4j client to map those domain objects to parameters the driver can understand.

[[neo4j-client-domain-example]]
[source,java]
.Example of a domain type
----
public class BikeOwner {

    private final String name;

    private final List<Bike> bikes;

    BikeOwner(String name, List<Bike> bikes) {
        this.name = name;
        this.bikes = new ArrayList<>(bikes);
    }

    public String getName() {
        return name;
    }

    public List<Bike> getBikes() {
        return Collections.unmodifiableList(bikes);
    }
}

public class Bike {

    private final String name;

    Bike(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
----

The mapping function has to fill in all named parameters that might occur in the query like <<neo4j-client-binder>> shows:

[[neo4j-client-binder]]
[source,java]
.Using a mapping function for binding domain objects
----
Mono<ResultSummary> summary = client
    .newQuery(""
        + "MERGE (u:User {name: 'Michael'}) "
        + "WITH u UNWIND $bikes as bike "
        + "MERGE (b:Bike {name: bike}) "
        + "MERGE (u) - [o:OWNS] -> (b) "
     )
    .bind(michael).with(bikeOwner -> { // <1>
        Map<String, Object> mappedValues = new HashMap<>();
        List<String> bikes = bikeOwner.getBikes().stream()
            .map(Bike::getName).collect(Collectors.toList());
        mappedValues.put("name", bikeOwner.getName());
        mappedValues.put("bikes", bikes)
        return mappedValues;
    })
    .run();
----
<1> The with method allows for specifying the binder function

==== Working with result objects

Both clients return collections or publishers of maps (`Map<String, Object>`).
Those maps corresponds exactly with the records that a query might have produced.

In addition, you can plugin your own `Function<Record, T>` through `fetchAs` to reproduce your domain object.

[[neo4j-client-reader]]
[source,java]
.Using a mapping function for reading domain objects
----
Mono<BikeOwner> bikeOwner = client
    .newQuery(""
        + " MATCH (o:User {name: $name}) - [:OWNS] -> (b:Bike)"
        + "RETURN o, collect(b) as bikes")
    .bind("michael").to("name")
    .fetchAs(BikeOwner.class).mappedBy((Record record) -> {
        List<Bike> bikes = record.get("bikes")
            .asList(v -> new Bike((v.get("name").asString())));
        return new BikeOwner(record.get("name").asString(), bikes);
    })
    .one();
----

==== Interacting directly with the driver while using managed transactions

In case you don't want or don't like the opinionated "client" approach of the `Neo4jClient` or the `ReactiveNeo4jClient`,
you can have the client delegate all interactions with the database to your code.
The interaction after the delegation is slightly different with the imperative and reactive versions of the client.

The imperative version takes in a `Function<StatementRunner, Optional<T>>` as a callback.
Returning an empty optional is ok.

[[neo4j-client-imperative-delegating]]
[source,java]
.Delegate database interaction to an imperative `StatementRunner`
----
Optional<Long> result = client
    .delegateTo((StatementRunner runner) -> {
        // Do as many interactions as you want
        long numberOfNodes = runner.run("MATCH (n) RETURN count(n) as cnt")
            .single().get("cnt").asLong();
        return Optional.of(numberOfNodes);
    })
    // .in("aDatabase") // <1>
    .run();
----
<1> The database selection as described in <<neo4j-client-selecting-the-target-database>> is optional

The reactive version receives a `RxStatementRunner`.

[[neo4j-client-reactive-delegating]]
[source,java]
.Delegate database interaction to a reactive `RxStatementRunner`
----
Mono<Integer> result = client
    .delegateTo((RxStatementRunner runner) ->
        Mono.from(runner.run("MATCH (n:Unused) DELETE n").summary())
            .map(ResultSummary::counters)
            .map(SummaryCounters::nodesDeleted))
    // .in("aDatabase") // <1>
    .run();
----
<1> Optional selection of the target database

Note that in both <<neo4j-client-imperative-delegating>> and <<neo4j-client-reactive-delegating>> the types of the runner have only been stated to provide more clarity to reader of this manual.