<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Michael Hunger, Oliver Gierke, Vince Bickers, Adam George, Michal Bachman">
<title>Good Relationships: The Spring Data Neo4j Guide Book</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove the comments around the @import statement below when using this as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img{page-break-inside:avoid}
thead{display:table-header-group}
img{max-width:100%!important}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Good Relationships: The Spring Data Neo4j Guide Book</h1>
<div class="details">
<span id="author" class="author">Michael Hunger</span><br>
<span id="author2" class="author">Oliver Gierke</span><br>
<span id="author3" class="author">Vince Bickers</span><br>
<span id="author4" class="author">Adam George</span><br>
<span id="author5" class="author">Michal Bachman</span><br>
<span id="revnumber">version {version},</span>
<span id="revdate">2015-02-05</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Neo4j Version 4-M1 (Feb 2015)</p>
</div>
<div class="paragraph">
<p>&#169; 2010-2015 Neo Technology, Inc. - Pivotal Software, Inc.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee
for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.
</td>
</tr>
</table>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#preface">Preface</a>
<ul class="sectlevel1">
<li><a href="#foreword">Foreword</a></li>
<li><a href="#about_this_guide_book">About this guide book</a>
<ul class="sectlevel2">
<li><a href="#the_spring_data_neo4j_project">The Spring Data Neo4j Project</a></li>
<li><a href="#feedback">Feedback</a></li>
<li><a href="#format_of_the_book">Format of the Book</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</li>
<li><a href="#neo4j">Introduction to Neo4j</a>
<ul class="sectlevel2">
<li><a href="#what_is_a_graph_database">What is a graph database?</a></li>
<li><a href="#about_neo4j">About Neo4j</a></li>
<li><a href="#querying_the_graph_with_cypher">Querying the Graph with Cypher</a></li>
<li><a href="#indexing">Indexing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Spring Data Neo4j 4 Reference Documentation</a>
<ul class="sectlevel1">
<li><a href="#reference_preface">About the Spring Data project</a>
<ul class="sectlevel2">
<li><a href="#about_sdn_4">About SDN 4</a></li>
</ul>
</li>
<li><a href="#overview">Overview</a>
<ul class="sectlevel2">
<li><a href="#getting_started">Getting started</a></li>
<li><a href="#adding_queries_and_computed_fields">Adding queries and computed fields</a></li>
<li><a href="#managing_relationships">Managing relationships</a></li>
<li><a href="#repositories">Repositories</a></li>
<li><a href="#neo4jtemplate">Neo4jTemplate</a></li>
<li><a href="#mapping_strategies">Mapping Strategies</a></li>
<li><a href="#transactional_support">Transactional support</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
</li>
<li><a href="#setup">Getting started</a>
<ul class="sectlevel2">
<li><a href="#dependencies_for_spring_data_neo4j">Dependencies for Spring Data Neo4j</a></li>
<li><a href="#spring_configuration">Spring configuration</a></li>
</ul>
</li>
<li><a href="#reference_programming-model">Programming model</a></li>
<li><a href="#reference_programming_model_mapping">1. Under the hood</a>
<ul class="sectlevel2">
<li><a href="#metadata_collection">1.1. Metadata collection</a></li>
<li><a href="#the_session_object">1.2. The Session object</a></li>
<li><a href="#explicit_save">1.3. Explicit save</a></li>
<li><a href="#fine_grained_control_via_depth_specification">1.4. Fine-grained control via depth specification</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_simple-mapping">2. Simplified Object-Graph Mapping</a></li>
<li><a href="#reference_programming_model_annotations">3. Defining node entities</a>
<ul class="sectlevel2">
<li><a href="#nodeentity_the_basic_building_block">3.1. @NodeEntity: The basic building block</a></li>
<li><a href="#graphid_neo4j_id_field">3.2. @GraphId: Neo4j id field</a></li>
<li><a href="#property_optional_annotation_for_property_fields">3.3. @Property: Optional annotation for property fields</a></li>
<li><a href="#query_fields_as_query_result_views">3.4. @Query: fields as query result views</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_relationships">4. Relating node entities</a>
<ul class="sectlevel2">
<li><a href="#relationship_connecting_node_entities">4.1. @Relationship: Connecting node entities</a></li>
<li><a href="#relationshipentity_rich_relationships">4.2. @RelationshipEntity: Rich relationships</a></li>
<li><a href="#reference_programming_model_relationships_relationshiptypediscrimination">4.3. Discriminating Relationships Based on End Node Type</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_indexing">5. Indexing</a>
<ul class="sectlevel2">
<li><a href="#index_management_in_spring_data_neo4j_4">5.1. Index Management in Spring Data Neo4j 4</a></li>
<li><a href="#index_queries_in_neo4jtemplate">5.2. Index queries in Neo4jTemplate</a></li>
<li><a href="#neo4j_auto_indexes">5.3. Neo4j Auto Indexes</a></li>
<li><a href="#spatial_indexes">5.4. Spatial Indexes</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_template">6. Neo4jTemplate</a>
<ul class="sectlevel2">
<li><a href="#basic_operations">6.1. Basic operations</a></li>
<li><a href="#entity_persistence">6.2. Entity-Persistence</a></li>
<li><a href="#cypher_queries">6.3. Cypher Queries</a></li>
<li><a href="#transactions">6.4. Transactions</a></li>
<li><a href="#lifecycle_events">6.5. Lifecycle Events</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_repositories">7. CRUD with repositories</a>
<ul class="sectlevel2">
<li><a href="#graphrepository">7.1. GraphRepository</a></li>
<li><a href="#query_and_finder_methods">7.2. Query and Finder Methods</a></li>
<li><a href="#creating_repositories">7.3. Creating repositories</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_conversion">8. Conversion</a>
<ul class="sectlevel2">
<li><a href="#reference_programming-model_conversion-built_in">8.1. Built-In Type Conversions</a></li>
<li><a href="#reference_programming-model_conversion-custom">8.2. Custom Type Conversion</a></li>
<li><a href="#reference_programming-model_mapresult">8.3. Mapping Query Results</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_transactions">9. Transactions</a></li>
<li><a href="#reference_programming_model_lifecycle">10. Entity Attachment</a>
<ul class="sectlevel2">
<li><a href="#reference_programming-model_lifecycle_persistence">10.1. Persisting Entities</a></li>
<li><a href="#reference_programming-model_detached_relating">10.2. Save Depth</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_typerepresentationstrategy">11. Entity Type Representation</a>
<ul class="sectlevel2">
<li><a href="#type_aliases">11.1. Type Aliases</a></li>
</ul>
</li>
<li><a href="#reference_programming_model_validation">12. Bean Validation (JSR-303)</a></li>
<li><a href="#reference_performance">Performance considerations</a>
<ul class="sectlevel2">
<li><a href="#a_little_history">A little history</a></li>
<li><a href="#focus_on_performance">Focus on performance</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migration">Migrating from previous versions of Spring Data Neo4j</a>
<ul class="sectlevel2">
<li><a href="#package_changes">1.1. Package changes</a></li>
<li><a href="#annotation_changes">1.2. Annotation changes</a></li>
<li><a href="#custom_converters">1.3. Custom Type Conversion</a></li>
<li><a href="#obsolete_annotations">1.4. Obsolete annotations</a></li>
<li><a href="#features_no_longer_supported">1.5. Features no longer supported</a></li>
<li><a href="#features_not_yet_included_in_milestone_1_but_that_are_on_the_roadmap">1.6. Features not yet included in Milestone 1 but that are on the Roadmap</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<h1 id="preface" class="sect0">Preface</h1>
<div class="sect1">
<h2 id="foreword">Foreword</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I’m excited about Spring Data Neo4j for several reasons.</p>
</div>
<div class="paragraph">
<p>First, this project is in a very important space. We are in an era of transition. A very few years ago, a relational database was a given for storing nearly all the data in nearly all applications. While relational databases remain important, new application requirements and massive data proliferation have prompted a richer choice of data stores. Graph databases have some very interesting strengths, and Neo4j is proving itself valuable in many applications. It&#8217;s a choice you should add to your toolbox.</p>
</div>
<div class="paragraph">
<p>Second, Spring Data Neo4j is an innovative project, which makes it easy to work with one of the most interesting new data stores. Unfortunately, the proliferation of new data stores has not been matched by innovation in programming models to work with them. Ironically, just after modern ORM mapping made working with relational data in Java relatively easy, the data store disruption occurred, and developers were back to square one: struggling once more with clumsy, low level APIs. Working with most non-relational technologies is overly complex and imposes too much work on developers. Spring Data Neo4j makes working with Neo4j amazingly easy, and therefore has the potential to make you more successful as a developer. Its use of AspectJ to eliminate persistence code from your domain model is truly innovative, and on the cutting edge of today’s Java technologies.</p>
</div>
<div class="paragraph">
<p>Third, I&#8217;m excited about Spring Data Neo4j for personal reasons. I no longer get to write code as often as I would like. My initial convictions that Spring and AspectJ could both make building applications with Neo4j dramatically easier and cross-store object navigation possible gave me an excuse for a much-needed coding binge early in 2010. This led to a prototype of what became Spring Data Neo4j — at times written paired with Emil. I’m sure the vast majority of my code has long since been replaced (probably for the better) by coders who aren&#8217;t rusty — thanks Michael and Thomas! — but I retain my pleasant memories.</p>
</div>
<div class="paragraph">
<p>Finally, Spring Data Neo4j is part of the broader Spring Data project: one of the key areas in which Spring is innovating to help meet new application requirements. I encourage you to explore Spring Data, and — better still — become involved in the community and contribute.</p>
</div>
<div class="paragraph">
<p>Enjoy the Spring Data Neo4j book, and happy coding!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Rod Johnson<br>
<cite>Founder of the Spring Framework</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Spring is the most popular middleware on the planet," I thought to myself as I walked up to Rod Johnson in late 2009 at the JAOO conference in Aarhus, Denmark. Rod had just given an introductory presentation about Spring Roo and when he was done I told him "Great talk. You&#8217;re clearly building a stack for the future. What about support for non-relational databases?"</p>
</div>
<div class="paragraph">
<p>We started talking and quickly agreed that NOSQL will play an important role in emerging stacks. Now, a year and half later, Spring Data Neo4j is available in its first stable release and I&#8217;m blown away by the result. Never before in any environment, in any programming framework, in any stack, has it been so easy and intuitive to tap into the power of a graph database like Neo4j. It&#8217;s a testament to the efforts by an awesome team of four hackers from Neo Technology and VMware: Michael Hunger, David Montag, Thomas Risberg and Mark Pollack.</p>
</div>
<div class="paragraph">
<p>The Spring framework revolutionized how we all wrote enterprise Java applications and today it&#8217;s used by millions of enterprise developers. Graph databases also stand out in the NOSQL crowd when it comes to enterprise adoption. You can find graph databases used in areas as diverse as network management, fraud detection, cloud management, anything with social data, geo and location services, master data management, bioinformatics, configuration databases, and much more.</p>
</div>
<div class="paragraph">
<p>Spring developers deserve access to the best tools available to solve their problem. Sometimes that&#8217;s a relational database accessed through JPA. But more often than not, a graph database like Neo4j is the perfect fit for your project. I hope that Spring Data Neo4j will give you access to the power and flexibility of graph databases while retaining the familiar productivity and convenience of the Spring framework.</p>
</div>
<div class="paragraph">
<p>Enjoy the Spring Data Neo4j guide book and welcome to the wonderful world of graph databases!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Emil Eifrem<br>
<cite>CEO of Neo Technology</cite>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about_this_guide_book">About this guide book</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="the_spring_data_neo4j_project">The Spring Data Neo4j Project</h3>
<div class="paragraph">
<p>Welcome to the Spring Data Neo4j Guide Book. Thank you for taking the time to get an in-depth look into <a href="http://spring.neo4j.org">Spring Data Neo4j</a>. This project is part of the <a href="http://springsource.org/spring-data">Spring Data project</a>, which brings the convenient programming model of the Spring Framework to modern NOSQL databases. Spring Data Neo4j, as the name alludes to, aims to provide support for the graph database <a href="http://neo4j.org">Neo4j</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="feedback">Feedback</h3>
<div class="paragraph">
<p>It was written by developers for developers. Hopefully we&#8217;ve created a guide that is well received by our peers.</p>
</div>
<div class="paragraph">
<p>If you have any feedback on Spring Data Neo4j or this book, please provide it via the <a href="http://spring.neo4j.org/issues">SpringSource JIRA</a>, the <a href="http://spring.neo4j.org/discussion">SpringSource NOSQL Forum</a>, <a href="http://github.com/spring-projects/spring-data-neo4j/issues">github comments or issues</a>, or the <a href="http://neo4j.org/forums/">Neo4j mailing list</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="format_of_the_book">Format of the Book</h3>
<div class="paragraph">
<p>This book is presented as a <a href="http://martinfowler.com/bliki/DuplexBook.html">duplex book</a>, a term coined by Martin Fowler. A duplex book consists of at least two parts. The first part is an easily accessible tutorial or narrative that gives the reader an overview of the topics contained in the book. It contains lots of examples and discussion topics. This part of the book is highly suited for cover-to-cover reading.</p>
</div>
<div class="paragraph">
<p>We chose a tutorial describing the creation of a web application that allows movie enthusiasts to find their favorite movies, rate them, connect with fellow movie geeks, and enjoy social features such as recommendations. The application is running on Neo4j using Spring Data Neo4j and the well-known Spring Web Stack.</p>
</div>
<div class="paragraph">
<p>The second part of the book is the classic reference documentation, containing detailed information about the library. It discusses the programming model, the underlying assumptions, and internals, as well as the APIs for the object-graph mapping. The reference documentation is typically used to look up concrete bits of information, or to drill down into certain topics. For hackers wanting to really delve into Spring Data Neo4j, it can of course also be read cover-to-cover.</p>
</div>
</div>
<div class="sect2">
<h3 id="acknowledgements">Acknowledgements</h3>
<div class="paragraph">
<p>We would like to thank everyone who contributed to this book, especially Mark Pollack and Thomas Risberg, the leads of the Spring Data Project, who helped a lot during the development of the library as well as sharing great feedback about the book. Also Oliver Gierke, our local German VMWare/SpringSource engineer, who invested a lot of time discussing various aspects of the library as well as providing the superb foundations for the Spring Data Repositories. We tortured Andy Clement, the AspectJ project lead, with many questions and issues around our advanced AspectJ usage which caused some headaches. He always quickly solved our issues and gave us excellent answers.</p>
</div>
<div class="paragraph">
<p>Many thanks to our colleagues David Montag, Andreas Kollegger and Rickard Öberg who not only contributed to Spring Data Neo4j but also provided content and feedback for this book.</p>
</div>
<div class="paragraph">
<p>We also appreciate very much the foresight of Rod Johnson and Emil Eifrem to initiate the project, and now also providing great forewords. Their leadership inspired collaboration between the engineering teams at SpringSource and Neo Technology, a tremendous help during the making of Spring Data Neo4j.</p>
</div>
<div class="paragraph">
<p>Last but not least we thank our vibrant community, both in the Spring Forums as well as on the Neo4j Mailing list and on many other places on the internet for giving us feedback, reporting issues and suggesting improvements. Without that important feedback we wouldn&#8217;t be where we are today. Especially Jean-Pierre Bergamin and Alfredas Chmieliauskas provided exceptional feedback and contributions.</p>
</div>
<div class="paragraph">
<p>Enjoy the book!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="neo4j">Introduction to Neo4j</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what_is_a_graph_database">What is a graph database?</h3>
<div class="paragraph">
<p>A graph database is a storage engine that is specialised in storing and retrieving vast networks of data. It efficiently
stores nodes and relationships and allows high performance traversal of those structures. Properties can be added to
nodes and relationships. Nodes can be labelled by zero or more labels, and relationships must have a direction and
exactly one type.</p>
</div>
<div class="paragraph">
<p>Graph databases are well suited for storing most kinds of domain models. In almost all domains, there are certain things
connected to other things. In most other modeling approaches, the relationships between things are reduced to a single
link without identity and attributes. Graph databases allow to keep the rich relationships that originate from the domain
equally well-represented in the database without resorting to also modeling the relationships as "things". There is very
little "impedance mismatch" when putting real-life domains into a graph database.</p>
</div>
</div>
<div class="sect2">
<h3 id="about_neo4j">About Neo4j</h3>
<div class="paragraph">
<p><a href="http://neo4j.org/">Neo4j</a> is a NOSQL graph database. It is a fully transactional database (ACID) that stores data
structured as graphs. A graph consists of nodes, connected by relationships. Inspired by the structure of the human mind,
it allows for high query performance on complex data, while remaining intuitive and simple for the developer.</p>
</div>
<div class="paragraph">
<p>Neo4j is very well-established.  It has been in commercial development for 15 years and in production for over 12 years. Most importantly, it has a helpful and contributing community surrounding it, but it also:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>has an intuitive, rich graph-oriented model for data representation. Instead of tables, rows, and columns, you work with a graph consisting of <a href="http://neo4j.com/docs/stable/what-is-a-graphdb.html">nodes, relationships, and properties</a>.</p>
</li>
<li>
<p>has a disk-based, native storage manager optimized for storing graph structures with maximum performance and scalability.</p>
</li>
<li>
<p>is scalable. Neo4j can handle graphs with many billions of nodes/relationships/properties on a single machine, but can also be scaled out across multiple machines for high availability.</p>
</li>
<li>
<p>has a powerful graph query language called Cypher, which allows users to efficiently read/write data by expressing graph patterns.</p>
</li>
<li>
<p>has a powerful traversal framework and query languages for traversing the graph.</p>
</li>
<li>
<p>can be deployed as a standalone server, which is the recommended way of using Neo4j</p>
</li>
<li>
<p>can be deployed as an embedded (in-process) database, giving developers access to its core Java <a href="http://api.neo4j.org/">API</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, Neo4j has ACID transactions, durable persistence, concurrency control, transaction recovery, high availability, and more. Neo4j is released under a dual free software/commercial licence model.</p>
</div>
</div>
<div class="sect2">
<h3 id="querying_the_graph_with_cypher">Querying the Graph with Cypher</h3>
<div class="paragraph">
<p>Neo4j provides a graph query language called <a href="http://neo4j.com/docs/stable/cypher-query-lang.html">"Cypher"</a> which
draws from many sources. It resembles SQL but with an iconic representation of patterns in the graph (concepts drawn from SPARQL).
The Cypher execution engine was written in Scala to leverage the high expressiveness for lazy sequence operations of
the language and the parser combinator library.</p>
</div>
<div class="paragraph">
<p>Cypher queries typically begin with a <code>MATCH</code> clause, which can be used to provide a way to pattern match against a
starting set of nodes, via their IDs or label-based index lookup. These starting patterns or start nodes, are then
related to other nodes via additional <code>MATCH</code> clauses. Match clauses can introduce new identifiers for nodes and relationships.
In the <code>WHERE</code> clause additional filtering of the result set is applied by evaluating expressions. The <code>RETURN</code> clause
defines which part of the query result will be available. Aggregation also happens in the return clause by using
aggregation functions on some of the values. Sorting can happen in the <code>ORDER BY</code> clause and the <code>SKIP</code> and <code>LIMIT</code>
parts restrict the result set to a certain window.</p>
</div>
<div class="paragraph">
<p>Cypher can be executed against a Neo4j server using an HTTP request.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Cypher Examples on the Cineasts.net Dataset</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Actors who acted in a Matrix movie:
MATCH (movie:Movie)&lt;-[:ACTS_IN]-(actor)
WHERE movie.title =~ 'Matrix.*'
RETURN actor.name, actor.birthplace

// User-Ratings:
MATCH (user:User {login:'micha'})-[r:RATED]-&gt;(movie)
WHERE r.stars &gt; 3
RETURN movie.title, r.stars, r.comment

// Mutual Friend recommendations:
MATCH (user:User {login:'micha'})-[:FRIEND]-(friend)-[r:RATED]-&gt;(movie)
WHERE r.stars &gt; 3
RETURN friend.name, movie.title, r.stars, r.comment

// Movie suggestions based on an actor:
MATCH (movie:Movie)&lt;-[:ACTS_IN]-()-[:ACTS_IN]-&gt;(suggestion:Movie)
WHERE id(movie)=13
RETURN suggestion.title, count(*) ORDER BY count(*) DESC LIMIT 5

// Co-Actors, sorted by count and name of Lucy Liu
MATCH (lucy)-[:ACTS_IN]-&gt;(movie)&lt;-[:ACTS_IN]-(co_actor)
WHERE lucy.name='Lucy Liu'
RETURN count(*), co_actor.name ORDER BY count(*) DESC, co_actor.name LIMIT 20

// Recommendations including counts, grouping and sorting
MATCH (:User {login:'micha'})-[:FRIEND]-()-[r:RATED]-&gt;(movie)
RETURN movie.title, avg(r.stars), count(*) ORDER BY avg(r.stars) DESC, count(*) DESC</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="indexing">Indexing</h3>
<div class="paragraph">
<p>The best way for retrieving start nodes for traversals and queries is by using Neo4j&#8217;s integrated index facilities.
Spring Data Neo4j takes the view that index maintenance should not be part of your application code. For that reason,
it does not provide any explicit index-related functionality.</p>
</div>
<div class="paragraph">
<p>However, it is very important that indices are in place for efficient node lookups.
Please make sure you read <a href="http://neo4j.com/docs/stable/query-schema-index.html">Neo4j Documentation</a>
on indices.</p>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0">Spring Data Neo4j 4 Reference Documentation</h1>
<div class="imageblock">
<div class="content">
<img src="springdatagraph.png" alt="springdatagraph">
</div>
</div>
<div class="paragraph">
<p>This part of the Spring Data Neo4j Guide book provides the reference documentation for SDN 4.</p>
</div>
<div class="paragraph">
<p>Its content covers information about the programming model, APIs, concepts, annotations and technical details of
Spring Data Neo4j, version 4.</p>
</div>
<div class="paragraph">
<p>Whenever you look for the means to employ the full power of the Spring Data Neo4j library, you should be able to find
your answers in the reference section. If you don&#8217;t, please inform us about missing or incorrect content so that we
can fix it.</p>
</div>
<div class="sect1">
<h2 id="reference_preface">About the Spring Data project</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://springsource.org/spring-data">Spring Data</a> is a SpringSource project that aims to provide Spring&#8217;s convenient
programming model and well known conventions for NOSQL databases. Currently there is support for graph (Neo4j),
key-value (Redis, Riak), document (MongoDB) and relational (Oracle) databases.</p>
</div>
<div class="paragraph">
<p>The Spring Data Neo4j project, as part of the Spring Data initiative, aims to simplify development with the Neo4j graph
database. Like JPA, it uses annotations on simple POJO domain objects. Together with metadata, the annotations drive
mapping the POJO entities and their fields to nodes, relationships, and properties in the graph database.</p>
</div>
<div class="sect2">
<h3 id="about_sdn_4">About SDN 4</h3>
<div class="paragraph">
<p>For version 4, Spring Data Neo4j has been rewritten from scratch to natively support Neo4j deployments in standalone
server mode. It uses Cypher, the Neo4j query language, and the HTTP protocol to communicate with the database.
It&#8217;s therefore worth noting that there <strong>may be some backward compatibility issues</strong> when migrating to version 4,
so be sure to check <a href="#migration">Migrating from previous versions of Spring Data Neo4j</a> to avoid any unwanted surprises.</p>
</div>
<div class="paragraph">
<p>For integration of Neo4j and other languages, please see <a href="http://neo4j.com/developer/language-guides/">Language Guides</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The explanation of Spring Data Neo4j&#8217;s programming model starts with some underlying details. The basic concepts of
the Object-Graph Mapping (OGM) library used by Spring Data Neo4j internally, is explained in the initial chapter.</p>
</div>
<div class="sect2">
<h3 id="getting_started">Getting started</h3>
<div class="paragraph">
<p>To get started with a simple application, you need only your domain model and (optionally) the annotations
(see <a href="#reference_programming_model_annotations">Defining node entities</a>) provided by the library. You use annotations to mark domain objects
to be reflected by nodes and relationships of the graph database. For individual fields the annotations allow you to
declare how they should be processed and mapped to the graph. For property fields and references to other entities this
is straightforward.</p>
</div>
</div>
<div class="sect2">
<h3 id="adding_queries_and_computed_fields">Adding queries and computed fields</h3>
<div class="paragraph">
<p>To use advanced functionality like Cypher queries, a basic understanding of the graph data model is required. The graph
data model is explained in the chapter about Neo4j, see <a href="#neo4j">Introduction to Neo4j</a>. Using computed fields that are dynamically
backed by graph operations is also possible by using the Query mechanism.</p>
</div>
</div>
<div class="sect2">
<h3 id="managing_relationships">Managing relationships</h3>
<div class="paragraph">
<p>Relationships between entities are first class citizens in a graph database and therefore worth a separate chapter
(<a href="#reference_programming_model_relationships">Relating node entities</a>) describing their usage in Spring Data Neo4j.</p>
</div>
</div>
<div class="sect2">
<h3 id="repositories">Repositories</h3>
<div class="paragraph">
<p>Spring Data Commons provides a very powerful repository infrastructure that is also leveraged in Spring Data Neo4j.
Those repositories consist only of a composition of interfaces that declare the available functionality in each repository.
The implementation details of commonly used persistence methods are handled by the library. At least for typical CRUD and
query-operations that is very convenient. The repositories are extensible by annotated, named or derived finder methods.
For custom implementations of repository methods you are free to add your own code. (<a href="#reference_programming_model_repositories">CRUD with repositories</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="neo4jtemplate">Neo4jTemplate</h3>
<div class="paragraph">
<p>Being a Spring Data library, Spring Data Neo4j still offers a <code>Neo4jTemplate</code> (<a href="#reference_programming_model_template">Neo4jTemplate</a>)
for interacting with the mapped entities and the Neo4j graph database if you don&#8217;t want to use repositories.
As of version 4, <code>Neo4jTemplate</code> is based on the <code>org.neo4j.ogm.session.Session</code> object. This is the same object
on which support for which Spring Data Neo4j Repositories is also based, so the underlying functionality is identical.</p>
</div>
</div>
<div class="sect2">
<h3 id="mapping_strategies">Mapping Strategies</h3>
<div class="paragraph">
<p>Because Neo4j is a schema-free database, Spring Data Neo4j uses a sophisticated mechanism to map Java types to Neo4j nodes
using labels. How that works is explained here: <a href="#reference_programming_model_typerepresentationstrategy">Entity Type Representation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactional_support">Transactional support</h3>
<div class="paragraph">
<p>Neo4j uses transactions to guarantee the integrity of your data and Spring Data Neo4j supports this fully. The implications
of this are described in the chapter around transactions. (<a href="#reference_programming_model_transactions">Transactions</a>)</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration">Configuration</h3>
<div class="paragraph">
<p>As of Milestone 1, only Java bean-based configuration is supported. See <a href="#setup">Getting started</a> for more details.</p>
</div>
</div>
<div class="sect2">
<h3 id="examples">Examples</h3>
<div class="paragraph">
<p>The provided samples, which are also publicly hosted on <a href="http://spring.neo4j.org/examples">Github</a>, are explained
in <a href="#reference_samples">[reference_samples]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="performance">Performance</h3>
<div class="paragraph">
<p>Spring Data Neo4j 4 has been rebuilt from the ground up with performance in mind. More information can be found in
<a href="#reference_performance">Performance considerations</a>. This chapter also discusses which use cases should not be handled with Spring Data Neo4j.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setup">Getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Neo4j dramatically simplifies development, but some setup is naturally required. For building the
application, Maven needs to be configured to include the Spring Data Neo4j dependencies and
after the build setup is complete, the Spring application needs to be configured to make use of Spring Data Neo4j.
Examples for these different setups can be found in the <a href="http://spring.neo4j.org/examples">Spring Data Neo4j examples</a>.</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j projects can be built using Maven, Gradle or Ant/Ivy.</p>
</div>
<div class="sect2">
<h3 id="dependencies_for_spring_data_neo4j">Dependencies for Spring Data Neo4j</h3>
<div class="exampleblock">
<div class="title">Example 2. Maven dependencies for Spring Data Neo4j</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;neo4j-spring&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring_configuration">Spring configuration</h3>
<div class="paragraph">
<p>Users of Spring Data Neo4j 4 can current only configure their applications using Java-based bean configuration. Support
for XML namespace configuration is expected to be available in Milestone 2</p>
</div>
<div class="sect3">
<h4 id="java_based_bean_configuration">Java-based bean configuration</h4>
<div class="paragraph">
<p>In order to configure Spring Data Neo4j with Java-based bean config, your Spring context must extend the core
<code>Neo4jConfiguration</code> context that comes with Spring Data Neo4j. The example below shows how this can be done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You will need to override the <code>neo4jServer()</code>, <code>getSessionFactory()</code> and <code>getSession()</code> bean definitions to provide
the required context for your own application. This is explained in more detail below.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 3. Pure Java bean configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableNeo4jRepositories(basePackages = "org.neo4j.example.repository")
@EnableTransactionManagement
public class Application extends Neo4jConfiguration {

    @Override
    @Bean
    public Neo4jServer neo4jServer() {
        return new RemoteServer("http://localhost:7474");
    }

    @Override
    @Bean
    public SessionFactory getSessionFactory() {
        return new SessionFactory("org.neo4j.example.domain");
    }

    @Override
    @Bean
    @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public Session getSession() throws Exception {
        return super.getSession();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="neo4jserver_bean">Neo4jServer Bean</h4>
<div class="paragraph">
<p>The <code>Neo4jServer</code> interface simply provides a URL with which to access the database.  The default implementations are <code>RemoteServer</code> and <code>InProcessServer</code>.</p>
</div>
<div class="paragraph">
<p>As the name implies, <code>RemoteServer</code> is used to provide the URL of a remote Neo4j server.  This will be the most typical use case for deployed applications.  As the above example shows, you simply construct a new instance with the URL of the server that you want to use.</p>
</div>
<div class="paragraph">
<p><code>InProcessServer</code> is useful for test and development environments.  This implementation will start a new instance of <code>CommunityNeoServer</code> running on an available local port and return the URL needed to connect to it.  It also registers a shutdown hook so that the underlying Neo4j server exits cleanly when the JVM shuts down, via <em>Control+C</em>, for example.</p>
</div>
</div>
<div class="sect3">
<h4 id="sessionfactory_bean">SessionFactory Bean</h4>
<div class="paragraph">
<p>The <code>SessionFactory</code> is needed by SDN to create instances of <code>org.neo4j.ogm.session.Session</code> as required.  This also sets up the object-graph mapping metadata when constructed, which is then used across all <code>Session</code> objects that it creates.  As seen in the above example, the packages to scan for domain object metadata should be provided to the <code>SessionFactory</code> constructor.</p>
</div>
<div class="paragraph">
<p>Note that the session factory should typically be application-scoped.  While you can use a narrower scope for this if you like, there is typically no advantage in doing so.</p>
</div>
</div>
<div class="sect3">
<h4 id="session_bean">Session Bean</h4>
<div class="paragraph">
<p>A <code>Session</code> is used to drive the object-graph mapping framework on which Spring Data Neo4j is based.  All repository implementations and <code>Neo4jTemplate</code> are driven by the <code>Session</code>, and you can also auto-wire it into your Spring beans and code against it directly if you wish.</p>
</div>
<div class="paragraph">
<p>The life cycle of a <code>Session</code> is important to consider because it keeps track of the changes that have been made to entities and their relationships.  The reason it does this is so that only entities and relationships that have changed get persisted on save, which is particularly efficient when working with large graphs.  Note, however, that the <code>Session</code> doesn&#8217;t ever return cached objects so there&#8217;s no risk of getting stale data on load; it always hits the database.</p>
</div>
<div class="paragraph">
<p>If your application relies on long-running sessions and doesn&#8217;t reload entities then you may not see changes made from other users and find yourself working with outdated objects.  On the other hand, if your sessions have too narrow a scope then your save operations can be unnecessarily expensive, as updates will be made to all objects if the session isn&#8217;t aware of the those that were originally loaded.</p>
</div>
<div class="paragraph">
<p>There&#8217;s therefore a trade off between the two approaches.  In general, the scope of a <code>Session</code> should correspond to a "unit of work" in your application.  What this means depends on the usage scenario, but in a typical web-based Spring application we recommend using a request-scoped or HTTP-session-scoped <code>Session</code>.  Either way, if you make sure you load fresh data at the beginning of each unit of work then data integrity shouldn&#8217;t be a problem.</p>
</div>
<div class="paragraph">
<p>Additional beans can be configured to be included in the Neo4j-Configuration just by defining them in the
Spring context in the normal way.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming-model">Programming model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers the fundamentals of the programming model behind Spring Data Neo4j.
It discusses the simple and advanced mapping modes, the annotations provided by Spring Data Neo4j and how to use them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_mapping">1. Under the hood</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="metadata_collection">1.1. Metadata collection</h3>
<div class="paragraph">
<p>Reflection and annotation-based metadata is collected about persistent entities in <code>org.neo4j.ogm.metadata.Metadata</code>
which provides it to any part of the library. This information is gathered by reading the class files directly rather
than loading via reflection, resulting in much faster startup times.</p>
</div>
<div class="paragraph">
<p>The information is stored in <code>ClassInfo</code> instances which hold all the required object-graph mapping information for each
type.  This metadata is discovered at start-up by specifying a list of packages in which all classes are scanned,
including those in sub-packages.  In order to omit a class from being metadata-mapped you should annotate it with <code>@Transient</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="the_session_object">1.2. The Session object</h3>
<div class="paragraph">
<p>The Spring repositories and <code>Neo4jTemplate</code> are both backed by <code>org.neo4j.ogm.session.Session</code>, which is a key component
of the framework.  The Session provides methods to load, save or delete object graphs from the database and also
provides transaction support.  The new <code>Neo4jTemplate</code> is essentially a wrapper around this <code>Session</code>, which exposes
all of its useful methods but handles transactions and provides the traditional Spring Data operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="explicit_save">1.3. Explicit save</h3>
<div class="paragraph">
<p>Unlike the original AspectJ-driven mapping, Spring Data Neo4j 4 doesn&#8217;t automatically commit when a
transaction closes, so an explicit call to <code>save(&#8230;&#8203;)</code> is required in order to persist changes to the database.</p>
</div>
</div>
<div class="sect2">
<h3 id="fine_grained_control_via_depth_specification">1.4. Fine-grained control via depth specification</h3>
<div class="paragraph">
<p>Spring Data Neo4j introduces the concept of persistence horizon. On any individual request, the persistence horizon
indicates how many edges should be traversed in the graph when loading or saving data. A horizon of zero means
that only the root object&#8217;s properties will be loaded or saved, a horizon of 1 will include the root object and all
its immediate neighbours, and so on. This attribute is enabled via a <code>depth</code> argument available on all repository and
template methods, but SDN 4 chooses sensible  defaults so that you don&#8217;t have to specify the depth attribute unless
you want change the default values.</p>
</div>
<div class="sect3">
<h4 id="default_depth_for_loading">1.4.1. Default depth for loading</h4>
<div class="paragraph">
<p>By default, loading an instance will map that object&#8217;s simple properties and its immediately-related objects (i.e. depth = 1).
This helps to avoid accidentally loading the entire graph into memory, but allows a single request to fetch not only the
object of immediate interest, but also its closest neighbours, which are likely also to be of interest. This strategy
attempts to strike a balance between loading too much of the graph into memory and having to make repeated requests
for data.</p>
</div>
<div class="paragraph">
<p>If parts of your graph structure a deep and not broad (for example a linked-list), you can increase the
load horizon for those nodes accordingly. Finally, if your graph will fit into memory, and you&#8217;d like to load
it all in one go, you can set the depth to -1.</p>
</div>
<div class="paragraph">
<p>On the other hand when fetching structures which are potentially very "bushy" (e.g. lists of things that themselves have
many relationships), you may want to set the load horizon to 0 (depth = 0) to avoid loading thousands of objects most
of which you won&#8217;t actually inspect.</p>
</div>
</div>
<div class="sect3">
<h4 id="default_depth_for_persisting">1.4.2. Default depth for persisting</h4>
<div class="paragraph">
<p>When persisting changes to the model, the default depth is -1. This means that <em>all</em> affected objects in the entity model
that are reachable from the root object being persisted will be modified in the graph. This is the recommended approach
because it means you can persist all your changes in one request. The OGM is able to detect which objects and relationships
require changing, so you won&#8217;t flood Neo4j with a bunch of objects that don&#8217;t require modification. You can change
the persistence depth to any value, but you should not make it less than the value used to load the corresponding data or
you run the risk of not having changes you expect to be made actually being persisted in the graph.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_simple-mapping">2. Simplified Object-Graph Mapping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of version 4, Spring Data Neo4j supports mapping annotated and non-annotated objects models.
It&#8217;s possible to save any POJO without annotations to the graph, as the framework applies conventions to decide what to do.
This is useful in cases when you don&#8217;t have control over the classes that you want to persist.
The recommended approach, however, is to use annotations wherever possible, since this gives greater control and means
that code can be refactored safely without risking breaking changes to the labels and relationships in your graph.</p>
</div>
<div class="paragraph">
<p>Annotated and non-annoted objects can be used within the same project without issue.  There is an <code>EntityAccessStrategy</code>
used to control how objects are read from or written to.  The default implementation of this uses the following convention:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Annotated method (getter/setter)</p>
</li>
<li>
<p>Annotated field</p>
</li>
<li>
<p>Plain method (getter/setter)</p>
</li>
<li>
<p>Plain field</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The object graph mapping comes into play whenever an entity is constructed from a node or relationship. This could be done
explicitly like during the lookup or create operations of the repositories and the <code>Neo4jTemplate</code> but also implicitly
while executing any graph operation that returns nodes or relationships and expecting mapped entities to be returned.</p>
</div>
<div class="paragraph">
<p>Unless annotations are used to specify otherwise, the framework will attempt to map any of an object&#8217;s "simple" fields
to node properties and any rich composite objects to related nodes.  A "simple" field is any primitive, boxed primitive
or String or arrays thereof, essentially anything that naturally fits into a Neo4j node property.  For related entities
the type of a relationship is inferred by the bean property name, as outlined in the <a href="#reference_programming-model_annotations">examples below</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_annotations">3. Defining node entities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Node entities are declared using the <code>@NodeEntity</code> annotation. Relationship entities use the <code>@RelationshipEntity</code> annotation.</p>
</div>
<div class="sect2">
<h3 id="nodeentity_the_basic_building_block">3.1. @NodeEntity: The basic building block</h3>
<div class="paragraph">
<p>The <code>@NodeEntity</code> annotation is used to declare that a POJO class is an entity backed by a node in the graph database. Fields on the entity are by default mapped to properties of the node. Fields referencing other node entities (or collections thereof) are linked with relationships.</p>
</div>
<div class="paragraph">
<p><code>@NodeEntity</code> annotations are inherited from super-types and interfaces. It is not necessary to annotate your domain objects at every inheritance level.</p>
</div>
<div class="paragraph">
<p>If the <code>label</code> attribute is set then this will replace the default label applied to the node in the database.  The default label is just the simple class name of the annotated entity.  All parent classes are also added as labels so that retrieving a collection of nodes via a parent type is supported.</p>
</div>
<div class="paragraph">
<p>Entity fields can be annotated with <code>@Property</code>, <code>@GraphId</code>, <code>@Transient</code> or <code>@Relationship</code>.  Support for <code>@Query</code> on fields is likely to be available in the full release but is unsupported as of milestone 1.  Marking a field with the transient modifier has the same effect as annotating it with <code>@Transient</code>; it won&#8217;t be persisted to the graph database.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Persisting an annotated entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Actor extends DomainObject {

   @GraphId
   private Long id;

   @Property(name="name")
   private String fullName;

   @Relationship(type="ACTED_IN", direction=Relationship.OUTGOING)
   private List&lt;Movie&gt; filmography;

}

@NodeEntity(label="Film")
public class Movie {

   @Property(name="title")
   private String name;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Saving a simple object graph containing one actor and one film using the above annotated objects would result in the following being persisted in Neo4j.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>(:Actor:DomainObject {name:'Tom Cruise'})-[:ACTED_IN]-&gt;(:Film {title:'Mission Impossible'})</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When annotating your objects, you can apply the annotations to either the fields or their accessor methods, but bear in mind the aforementioned <code>EntityAccessStrategy</code> ordering when annotating your domain model.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Persisting a non-annotated entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Actor extends DomainObject {

   private Long id;
   private String fullName;
   private List&lt;Movie&gt; filmography;

}

public class Movie {

   private String name;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, a graph similar to the following would be persisted.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>(:Actor:DomainObject {fullName:'Tom Cruise'})-[:FILMOGRAPHY]-&gt;(:Movie {name:'Mission Impossible'})</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While this will map successfully to the database, it&#8217;s important to understand that the names of the properties and relationship types are tightly coupled to the class&#8217;s member names.  Renaming any of these fields will cause parts of the graph to map incorrectly, hence the recommendation to use annotations.</p>
</div>
</div>
<div class="sect2">
<h3 id="graphid_neo4j_id_field">3.2. @GraphId: Neo4j id field</h3>
<div class="paragraph">
<p>This is a required field which must be of type <code>Long</code>. It is used by Spring Data Neo4j to store the node or relationship-id to re-connect the entity to the graph.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It must not be a primitive type because then an object in a transient state cannot be represented, as the default value 0 would point to the reference node.  Please also make sure that an <code>equals()</code> and <code>hashCode()</code> method have to be provided which take the <code>id</code> field into account (and also handle the "non-attached", null case).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the field is simply named 'id' then it is not necessary to annotate it with <code>@GraphId</code> as the OGM will use it automatically.</p>
</div>
<div class="sect3">
<h4 id="entity_equality">3.2.1. Entity Equality</h4>
<div class="paragraph">
<p>Entity equality can be a grey area, and it is debatable whether natural keys or database ids best describe equality, there is the issue of versioning over time, etc.  In previous versions of Spring Data Neo4j it was recommended to honour the convention that database-issued ids are the basis for equality, despite the consequences.</p>
</div>
<div class="paragraph">
<p>In version 4, the dependency of the framework upon a particular style of <code>equals()</code> or <code>hashCode()</code> implementation has been abolished.  The graph ID field is directly checked to see if two entities represent the same node and a 64-bit hash code is used for dirty checking, so you&#8217;re not forced to write your code in a certain way - a sin committed by many other mapping frameworks out there!</p>
</div>
<div class="paragraph">
<p>However, we do think it&#8217;s important to mention that if you use the <code>@GraphId</code> field in your <code>hashCode()</code> method then this comes with a caveat.  When you first persist an entity, its hashcode changes because Spring Data Neo4j populates the database ID on save.</p>
</div>
<div class="paragraph">
<p>That causes problems if you had inserted the newly created entity into a hash-based collection before saving. While that can be worked around, we strongly advise you adopt a convention of not relying upon the graph ID for object equality.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="property_optional_annotation_for_property_fields">3.3. @Property: Optional annotation for property fields</h3>
<div class="paragraph">
<p>As we touched on earlier, it is not necessary to annotate property fields as they are persisted by default.  All fields that contain primitive values are persisted directly to the graph. All fields convertible to a <code>String</code> using the Spring conversion services will be stored as a string.  Spring Data Neo4j includes default type converters that deal with the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code> to a String in the ISO 8601 format: "yyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSXXX"</p>
</li>
<li>
<p><code>java.math.BigInteger</code> to a String property</p>
</li>
<li>
<p><code>java.math.BigDecimal</code> to a String property</p>
</li>
<li>
<p>binary data (as byte[] or Byte[]) to base-64 String</p>
</li>
<li>
<p><code>java.lang.Enum</code> types using the enum&#8217;s <code>name()</code> method and <code>Enum.valueOf()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Collections of primitive or convertible values are stored as well. They are converted to arrays of their type or strings respectively.  Custom converters are also specified by using <code>@Convert</code> - this is discussed in detail <a href="#reference_programming-model_conversion">later on</a>.</p>
</div>
<div class="paragraph">
<p>Node property names can be explicitly assigned by setting the <code>name</code> attribute.  For example <code>@Property(name="last_name") String lastName</code>.  The node property name defaults to the field name when not specified.</p>
</div>
</div>
<div class="sect2">
<h3 id="query_fields_as_query_result_views">3.4. @Query: fields as query result views</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This is not supported on entity fields for milestone one, although it does work in repositories
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>@Query</code> annotation leverages the delegation infrastructure supported by Spring Data Neo4j. It provides dynamic fields which, when accessed, return the values selected by the provided query language expression. The provided query must contain a placeholder named <code>{self}</code> for the the current entity.
For instance the query <code>MATCH ({self}-[:FRIEND_OF]&#8594;(friend) RETURN friend</code>. Graph queries can return variable number of entities. That&#8217;s why annotation can be put onto fields with a single value, a subclass of Iterable of a concrete type or an Iterable of <code>Map&lt;String,Object&gt;</code>. Additional parameters are taken from the params attribute of the <code>@Query</code> annotation. These parameter tuples form key-value pairs that are provided to the query at execution time.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. @Graph on a node entity field</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Group {
    @Query(value = "MATCH ({self})-[r]-&gt;(friend) WHERE r.type={relType} RETURN friend",
                params = {"relType", "FRIEND_OF"})
    private Iterable&lt;Person&gt; friends;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_relationships">4. Relating node entities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since relationships are first-class citizens in Neo4j, associations between node entities are represented by relationships. In general, relationships are categorized by a type, and start and end nodes (which imply the direction of the relationship). Relationships can have an arbitrary number of properties. Spring Data Neo4j has special support to represent Neo4j relationships as entities too, but it is often not needed.</p>
</div>
<div class="sect2">
<h3 id="relationship_connecting_node_entities">4.1. @Relationship: Connecting node entities</h3>
<div class="paragraph">
<p>Every field of a node entity that references one or more other node entities is backed by relationships in the graph. These relationships are managed by Spring Data Neo4j automatically.</p>
</div>
<div class="paragraph">
<p>The simplest kind of relationship is a single field pointing to another node entity (1:1). In this case, the field does not have to be annotated at all, although the annotation may be used to control the direction and type of the relationship. When setting the field, a relationship is created when the entity is persisted. If the field is set to <code>null</code>, the relationship is removed.</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Single relationship field</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Movie {
    private Actor topActor;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is also possible to have fields that reference a set of node entities (1:N). These fields come in two forms, modifiable or read-only. Modifiable fields are of the type <code>Collection&lt;T&gt;</code>, and read-only fields are <code>Iterable&lt;T&gt;</code>, where T is a type annotated with <code>@NodeEntity</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Node entity with relationships</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Actor {
    @Relationship(type = "TOP_ACTOR", direction = Relationship.INCOMING)
    private Set&lt;Movie&gt; topActorIn;

    @Relationship(type = "ACTS_IN")
    private Set&lt;Movie&gt; movies;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For graph to object mapping, the automatic transitive loading of related entities depends on the depth of the search specified on the call to <code>Session.load()</code>.  By default, the <em>related</em> node or relationship entities will just be loaded to minimum depth 0, which means their properties will be set but no further related entities will be populated.</p>
</div>
<div class="paragraph">
<p>If this <code>Set</code> of related entities is modified, the changes are reflected in the graph once the root object (<code>Actor</code>, in this case) is saved.  Relationships are added, removed or updated according to the differences between the root object that was loaded and the corresponding one that was saved..</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j ensures by default that there is only one relationship of a given type between any two given entities.  In previous versions of the framework <code>Direction.BOTH</code> could be used but this is no longer supported, since relationships are navigable in both directions anyway so duplicates don&#8217;t need to be created.  If you don&#8217;t care about the direction then you can specify <code>direction=Relationship.UNDIRECTED</code> which will guarantee that the path between two node entities is navigable from either side..</p>
</div>
</div>
<div class="sect2">
<h3 id="relationshipentity_rich_relationships">4.2. @RelationshipEntity: Rich relationships</h3>
<div class="paragraph">
<p>To access the full data model of graph relationships, POJOs can also be annotated with <code>@RelationshipEntity</code>, making them relationship entities. Just as node entities represent nodes in the graph, relationship entities represent relationships. As described above, fields annotated with <code>@Relationship</code> provide a way to only link node entities via relationships, but it provides no way of accessing the relationships themselves.</p>
</div>
<div class="paragraph">
<p>Fields in relationship entities are similar to node entities, in that they&#8217;re persisted as properties on the relationship. For accessing the two endpoints of the relationship, two special annotations are available: <code>@StartNode</code> and <code>@EndNode</code>. A field annotated with one of these annotations will provide read-only access to the corresponding endpoint, depending on the chosen annotation.</p>
</div>
<div class="paragraph">
<p>For the relationship-type a <code>String</code> attribute called <code>type</code> is available on the <code>@RelationshipEntity</code> annotation.  Rather like the simple strategy for labelling node entities, if this is unset then the name of the class is used to derive the relationship type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You must include <code>@RelationshipEntity</code> plus exactly one <code>@StartNode</code> field and one <code>@EndNode</code> field on your relationship entity classes or the OGM will throw a MappingException when reading or writing.  It is not possible to use relationship entities in a non-annotated domain model.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 9. A simple Relationship entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Actor {

    private Role playedIn;

}

@RelationshipEntity
public class Role {

    @GraphId
    private Long relationshipId;
    @Property(name="partPlayed")
    private String title;
    @StartNode
    private Actor actor;
    @EndNode
    private Movie movie;

}

@NodeEntity
public class Movie {

    private String title;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In previous versions of Spring Data Neo4j, a dynamic relationship type was supported.  However, this has been dropped completely for version 4, since it was not possible to manage it effectively for both reading from and writing to the graph.</p>
</div>
</div>
<div class="sect2">
<h3 id="reference_programming_model_relationships_relationshiptypediscrimination">4.3. Discriminating Relationships Based on End Node Type</h3>
<div class="paragraph">
<p>In some cases, you want to model two different aspects of a conceptual relationship using the same relationship type.
Here is a canonical example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Clashing Relationship Types</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
class Person {
    @Relationship(type="OWNS")
    private Car car;

    @Relationship(type="OWNS")
    private Pet pet;
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In previous versions of Spring Data Neo4j, you would have to add an <code>enforceTargetType</code> attribute into every clashing
<code>@Relationship</code> annotation for this to map correctly.  Thanks to changes in the underlying object-graph mapping mechanism,
this is no longer necessary and the above will work just fine.</p>
</div>
<div class="paragraph">
<p>However, please be aware that this will only work because the end node types (Car and Pet) are different types.
If you wanted a person to own two cars, for example, then you&#8217;d have to use a <code>Collection</code> of cars or use differently-named relationship types.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_indexing">5. Indexing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Indexing is used in Neo4j to quickly find nodes and relationships from which to start graph operations. Either for manually traversing the graph, using the traversal framework, cypher queries or for "global" graph operations. Indexes are also employed to ensure uniqueness of elements with certain labels and properties.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Please note that the lucene-based manual indexes are deprecated with Neo4j 2.0. The default index is now based on labels and schema indexes and the related old APIs have been deprecated as well. The "legacy" index framework should only be used for fulltext and spatial indexes which are not currently supported via schema-based indexes.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="index_management_in_spring_data_neo4j_4">5.1. Index Management in Spring Data Neo4j 4</h3>
<div class="paragraph">
<p>From Spring Data Neo4j 4, <code>@Indexed</code> no longer exists.  The reason for this is because index creation should not be the job of the mapping framework, but should instead be managed within the database environment and tuned for the particular use case of your application.  Indexes shouldn&#8217;t be added arbitrarily to fields by developers, but should instead be the result of design decisions made alongside the rest of the performance requirements.</p>
</div>
<div class="paragraph">
<p>Index creation and management is therefore now outside the scope of this document.  Please see the Neo4j documention on indexes for for information:  <a href="http://neo4j.com/docs/stable/query-schema-index.html" class="bare">http://neo4j.com/docs/stable/query-schema-index.html</a></p>
</div>
</div>
<div class="sect2">
<h3 id="index_queries_in_neo4jtemplate">5.2. Index queries in Neo4jTemplate</h3>
<div class="paragraph">
<p>For querying on indexes, certainly as of SDN 4 milestone one, your best bet is to take advantage of the <code>GraphRepository</code> load-by-property methods, or the corresponding ones on <code>Neo4jTemplate</code>.  If you know that particular properties are indexed in the database then this will ensure that the indexes are utilised so you still take advantage of the performance benefits.</p>
</div>
<div class="paragraph">
<p>In the full release, the ability to do this through Spring repositories should also be fully implemented.</p>
</div>
</div>
<div class="sect2">
<h3 id="neo4j_auto_indexes">5.3. Neo4j Auto Indexes</h3>
<div class="paragraph">
<p>Neo4j allows to configure (legacy) <a href="http://neo4j.com/docs/stable/auto-indexing.html">auto-indexing</a> for certain properties on nodes and relationships.  It is possible to use the specific index names <code>node_auto_index</code> and <code>relationship_auto_index</code> when querying indexes in Spring Data Neo4j either with the query methods in template and repositories or via Cypher.</p>
</div>
</div>
<div class="sect2">
<h3 id="spatial_indexes">5.4. Spatial Indexes</h3>
<div class="paragraph">
<p>Older versions of Spring Data Neo4j offered limited support for spatial queries using the <code>neo4j-spatial</code> library. However, as of SDN 4 milestone 1 at least, this is no longer supported.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_template">6. Neo4jTemplate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>Neo4jTemplate</code> offers the convenient API of Spring templates for the Neo4j graph database.  As of version 4, the Spring Data Neo4j Template wraps the underlying object-graph mapping <code>Session</code>, but still provides the core functionality to persist objects to the graph and load them in a variety of ways.  Indeed, you can just use the <code>Session</code> directly in your code if you need greater control, but the <code>Neo4jTemplate</code> may well be easier for general use.</p>
</div>
<div class="sect2">
<h3 id="basic_operations">6.1. Basic operations</h3>
<div class="paragraph">
<p>For Spring Data Neo4j 4, the changes to the underlying architecture have led to the pruning of the <code>Neo4jTemplate</code> feature set.  Basic operations are now entirely limited to CRUD operations on entities and executing arbitrary Cypher queries; more low-level manipulation of the graph database is not possible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
There is no longer a way to manipulate relationships and nodes directly.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Given that the latest version of the framework is driven by Cypher queries alone, there&#8217;s no way to work directly with <code>Node</code> and <code>Relationship</code> objects any more in remote server mode.  Similarly, the <code>traverse()</code> method has disappeared, again because the underlying query-driven model doesn&#8217;t handle it in an efficient way.</p>
</div>
<div class="paragraph">
<p>If you find yourself in trouble because of the omission of these features, then your best options are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write a Cypher query to perform the operations on the nodes/relationships instead</p>
</li>
<li>
<p>Write a Neo4j server plugin and call it over REST from your application</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Of course, there are pros and cons to both of these approaches, but these are largely outside the scope of this document.  In general, for low-level operations like complex graph traversals you&#8217;ll get the best performance by writing a server-side plugin, which is generally easier to test and maintain than the sort of solution available with earlier versions of SDN anyway.  For many purposes, though, Cypher will be performant and expressive enough to perform the operations that you need.</p>
</div>
</div>
<div class="sect2">
<h3 id="entity_persistence">6.2. Entity-Persistence</h3>
<div class="paragraph">
<p><code>Neo4jTemplate</code> allows to <code>save</code>, <code>load(One/All)</code> and <code>delete</code> entities.  However, as of SDN 4, it no longer provides the stored type information via <code>getStoredJavaType</code>.  The eagerness with which objects are retrieved is controlled by specifying the 'depth' argument to any of the load methods.</p>
</div>
<div class="paragraph">
<p>All of these basic CRUD methods just call onto the corresponding methods of <code>Session</code>, albeit with transaction handling thrown in to save you the effort of manually managing them.</p>
</div>
</div>
<div class="sect2">
<h3 id="cypher_queries">6.3. Cypher Queries</h3>
<div class="paragraph">
<p>The <code>Neo4jTemplate</code> also allows execution of arbitrary Cypher queries via its <code>query</code>, <code>queryForObject</code> and <code>queryForObjects</code> methods.  Cypher queries that return tabular results should be passed into the <code>query</code> method and an <code>Iterable&lt;Map&lt;String,Object&gt;&gt;</code> containing the raw data is returned, which can be either used as it is or converted as needed.</p>
</div>
<div class="paragraph">
<p>For the query methods that retrieve mapped objects, the recommended query format is to return a path, which should ensure that known types get mapped correctly and joined together with relationships as appropriate.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactions">6.4. Transactions</h3>
<div class="paragraph">
<p>The <code>Neo4jTemplate</code> provides implicit transactions for some of its methods. For instance <code>save</code> uses them. For other modifying operations please provide Spring Transaction management using <code>@Transactional</code> or the <code>TransactionTemplate</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="lifecycle_events">6.5. Lifecycle Events</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
These events are not implemented as of milestone 1 of SDN 4.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Neo4j Template offers basic lifecycle events via Spring&#8217;s event mechanism using ApplicationListener and ApplicationEvent. The following hooks are available in the form of types of application event:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BeforeSaveEvent</p>
</li>
<li>
<p>AfterSaveEvent</p>
</li>
<li>
<p>DeleteEvent - after the event has been deleted</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example demonstrates how to hook into the application lifecycle and register listeners that perform behaviour across types of entities during this life cycle:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Auditing Entities and Generating Unique Application-level IDs</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableNeo4jRepositories
public class ApplicationConfig extends Neo4jConfiguration {
    ...
    @Bean
    ApplicationListener&lt;BeforeSaveEvent&gt; beforeSaveEventApplicationListener() {
        return new ApplicationListener&lt;BeforeSaveEvent&gt;() {
            @Override
            public void onApplicationEvent(BeforeSaveEvent event) {
                AcmeEntity entity = (AcmeEntity) event.getEntity();
                entity.setUniqueId(acmeIdFactory.create());
            }
        };
    }

    @Bean
    ApplicationListener&lt;AfterSaveEvent&gt; afterSaveEventApplicationListener() {
        return new ApplicationListener&lt;AfterSaveEvent&gt;() {
            @Override
            public void onApplicationEvent(AfterSaveEvent event) {
                AcmeEntity entity = (AcmeEntity) event.getEntity();
                auditLog.onEventSaved(entity);
            }
        };
    }

    @Bean
    ApplicationListener&lt;DeleteEvent&gt; deleteEventApplicationListener() {
        return new ApplicationListener&lt;DeleteEvent&gt;() {
            @Override
            public void onApplicationEvent(DeleteEvent event) {
                AcmeEntity entity = (AcmeEntity) event.getEntity();
                auditLog.onEventDeleted(entity);
            }
        };
    }
    ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Changes made to entities in the before-save event handler are reflected in the stored entity - after-save ones are not.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_repositories">7. CRUD with repositories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The repositories provided by Spring Data Neo4j build on the composable repository infrastructure in <a href="http://static.springsource.org/spring-data/data-commons/docs/current/reference/html/#repositories">Spring Data Commons</a>. They allow for interface-based composition of repositories consisting of provided default implementations for certain interfaces and additional custom implementations for other methods.</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j comes with a single <code>org.springframework.data.repository.CrudRepository</code> specialisation called
<code>GraphRepository&lt;T&gt;</code> used for all object-graph mapping repositories.  This sub-interface also adds specific finder methods
that take a <em>depth</em> argument to control the eagerness with which related entities are fetched. Generally, it has all the
desired repository methods. If other operations are required then the additional repository interfaces should be added
to the individual interface declaration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>GraphRepository</code> no longer combines <code>IndexRepository</code> and <code>TraversalRepository</code> because, for reasons explained
above, these features are no longer supported in Spring Data Neo4j as of version 4.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="graphrepository">7.1. GraphRepository</h3>
<div class="paragraph">
<p>As of SDN 4, this <code>GraphRepository&lt;T&gt;</code> should be the interface from which your entity repository interfaces inherit,
with <code>T</code> being specified as the node entity type to persist.</p>
</div>
<div class="paragraph">
<p>There is also no <code>TypeRepresentationStrategy</code> in the latest framework version.  Instead, the type representation strategy
has been greatly simplified to use a single label-based mechanism as described in more detail here: <a href="#reference_programming-model_typerepresentationstrategy">[reference_programming-model_typerepresentationstrategy]</a></p>
</div>
<div class="paragraph">
<p>Examples of methods you get for free out of <code>GraphRepository</code> are as follows.  For all of these examples the ID parameter
is a <code>Long</code> that matches the graph ID:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Load an entity instance via an id</dt>
<dd>
<p><code>T findOne(id)</code></p>
</dd>
<dt class="hdlist1">Check for existence of an id in the graph</dt>
<dd>
<p><code>boolean exists(id)</code></p>
</dd>
<dt class="hdlist1">Iterate over all nodes of a node entity type</dt>
<dd>
<p><code>Iterable&lt;T&gt; findAll()</code> <code>Iterable&lt;T&gt; findAll(Sort)</code></p>
</dd>
<dt class="hdlist1">Count the instances of the repository entity type</dt>
<dd>
<p><code>Long count()</code></p>
</dd>
<dt class="hdlist1">Save entities</dt>
<dd>
<p><code>T save(T)</code> and <code>Iterable&lt;T&gt; save(Iterable&lt;T&gt;)</code></p>
</dd>
<dt class="hdlist1">Delete graph entities</dt>
<dd>
<p><code>void delete(T)</code>, <code>void delete(Iterable&lt;T&gt;)</code>, and <code>void deleteAll()</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="query_and_finder_methods">7.2. Query and Finder Methods</h3>
<div class="sect3">
<h4 id="reference_programming-model_annotatedQueries">7.2.1. Annotated queries</h4>
<div class="paragraph">
<p>Queries using the Cypher graph query language can be supplied with the <code>@Query</code> annotation. That means every method
annotated with <code>@Query("start n=node:IndexName(key={node or 0}) match (n)-&#8594;(m) return m")</code> will use the supplied query string. The named or indexed parameter <code>{node}</code> will be substituted by the actual method parameter. Node and Relationship-Entities are handled directly, Iterables thereof as well. All other parameters are replaced directly (i.e. Strings, Longs, etc).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
As of milestone 1 of Spring Data Neo4j 4, paging is not natively supported
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="query_results">7.2.2. Query results</h4>
<div class="paragraph">
<p>Typical results for queries are <code>Iterable&lt;Type&gt;</code>, <code>Iterable&lt;Map&lt;String,Object&gt;&gt;</code> or <code>Type</code>.  As of milestone one,
<code>Slice&lt;Type&gt;</code> and <code>Page&lt;Type&gt;</code> are not supported. Nodes and relationships are converted to their respective entities
(if they exist). Other values are converted using the registered <a href="#reference_programming-model_conversion">conversion
services</a> (e.g. enums).</p>
</div>
</div>
<div class="sect3">
<h4 id="cypher_examples">7.2.3. Cypher examples</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MATCH (n) WHERE id(n)=9 RETURN n</code></dt>
<dd>
<p>returns the node with id 9</p>
</dd>
<dt class="hdlist1"><code>MATCH (movie:Movie {title:'Matrix'}) RETURN movie</code></dt>
<dd>
<p>returns the nodes which are indexed with title equal to 'Matrix'</p>
</dd>
<dt class="hdlist1"><code>MATCH (movie:Movie {title:'Matrix'})&#8592;[:ACTS_IN]-(actor) RETURN actor.name</code></dt>
<dd>
<p>returns the names of the actors that have a ACTS_IN relationship to the movie node for 'Matrix'</p>
</dd>
<dt class="hdlist1"><code>MATCH (movie:Movie {title:'Matrix'})&#8592;[r:RATED]-(user) WHERE r.stars &gt; 3 RETURN user.name, r.stars, r.comment</code></dt>
<dd>
<p>returns users names and their ratings (&gt;3) of the movie titled 'Matrix'</p>
</dd>
<dt class="hdlist1"><code>(user:User {login='micha'})-[:FRIEND]-(friend)-[r:RATED]&#8594;(movie) RETURN movie.title, AVG(r.stars), COUNT(<strong>) ORDER BY AVG(r.stars) DESC, COUNT(</strong>) DESC</code></dt>
<dd>
<p>returns the movies rated by the friends of the user 'micha', aggregated by movie.title, with averaged ratings and rating-counts sorted by both</p>
</dd>
</dl>
</div>
<div class="paragraph">
<div class="title">Examples of Cypher queries placed on repository methods with @Query where values are replaced with method parameters,</div>
<p>as described in the <a href="#reference_programming-model_annotatedQueries">Annotated queries</a>) section.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface MovieRepository extends GraphRepository&lt;Movie&gt; {

    // returns the node with id equal to idOfMovie parameter
    @Query("MATCH (n) WHERE id(n)={0} RETURN n")
    Movie getMovieFromId(Integer idOfMovie);

    // returns the nodes which will use index named title equal to movieTitle parameter
    // movieTitle String must not contain any spaces, otherwise you will receive a NullPointerException.
    @Query("MATCH (movie:Movie {title={0}}) RETURN movie")
    Movie getMovieFromTitle(String movieTitle);

    // returns the Actors that have a ACTS_IN relationship to the movie node with the title equal to movieTitle parameter.
    // (The parenthesis around 'movie' and 'actor' in the match clause are optional.)
    @Query("MATCH (movie:Movie {title={0}})&lt;-[:ACTS_IN]-(actor) RETURN actor")
    Page&lt;Actor&gt; getActorsThatActInMovieFromTitle(String movieTitle, PageRequest);

    // returns users who rated a movie (movie parameter) higher than rating (rating parameter)
    @Query("MATCH (movie:Movie)&lt;-[r:RATED]-(user) " +
           "WHERE id(movie)={0} AND r.stars &gt; {1} " +
           "RETURN user")
    Iterable&lt;User&gt; getUsersWhoRatedMovieFromTitle(Movie movie, Integer rating);

    // returns users who rated a movie based on movie title (movieTitle parameter) higher than rating (rating parameter)
    @Query("MATCH (movie:Movie {title:{0}})&lt;-[r:RATED]-(user) " +
           "WHERE r.stars &gt; {1} " +
           "RETURN user")
     Iterable&lt;User&gt; getUsersWhoRatedMovieFromTitle(String movieTitle, Integer rating);
 }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="queries_derived_from_finder_method_names">7.2.4. Queries derived from finder-method names</h4>
<div class="paragraph">
<p>As known from Rails or Grails it is possible to derive queries for domain entities from finder method names like
<code>Iterable&lt;Person&gt; findByNameAndAgeGreaterThan(String name, int age)</code>. Using the metadata infrastructure in the underlying
object-graph mapper, a finder method name can be split into its semantic parts and converted into a cypher query.  Navigation along relationships will be reflected in the generated <code>MATCH</code> clause and properties with operators will end up as expressions in the <code>WHERE</code> clause.  Order and limiting of the query will by handled by provided <code>Pageable</code> or <code>Sort</code> parameters.  The other parameters will be used in the order they appear in the method signature so they should align with the expressions stated in the method name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This feature is unsupported as of SDN 4 Milestone 1
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 12. Some examples of methods and corresponding Cypher queries of a PersonRepository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends GraphRepository&lt;Person&gt; {

    // MATCH (person:Person {name={0}}) RETURN person
    Person findByName(String name);

    // MATCH (person:Person) WHERE person.name =~ '.*{0}.*' RETURN person
    Iterable&lt;Person&gt; findByNameLike(String name)

    // MATCH (person:Person)
    // WHERE person.age = {0} AND person.married = {1}
    // RETURN person
    Iterable&lt;Person&gt; findByAgeAndMarried(int age, boolean married)

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="derived_finder_methods">7.2.5. Derived Finder Methods</h4>
<div class="paragraph">
<p>Use the meta information of your domain model classes to declare repository finders that navigate along relationships
and compare properties. The path defined with the method name is used to create a Cypher query that is executed on the graph.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This feature is unsupported as of SDN 4 Milestone 1
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 13. Repository and usage of derived finder methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public static class Person {
    @GraphId Long id;
    private String name;
    private Group group;

    private Person(){}
    public Person(String name) {
        this.name = name;
    }
}

@NodeEntity
public static class Group {
    @GraphId Long id;
    private String title;
    // incoming relationship for the person -&gt; group
    @Relationship(type = "group", direction = Relationship.INCOMING)
    private Set&lt;Person&gt; members = new HashSet&lt;&gt;();

    private Group(){}
    public Group(String title, Person... people) {
        this.title = title;
        members.addAll(asList(people));
    }
}
public interface PersonRepository extends GraphRepository&lt;Person&gt; {
    Iterable&lt;Person&gt; findByGroupTitle(String name);
}

@Autowired PersonRepository personRepository;

Person oliver=personRepository.save(new Person("Oliver"));
final Group springData = new Group("spring-data",oliver);
groupRepository.save(springData);

final Iterable&lt;Person&gt; members = personRepository.findByGroupTitle("spring-data");
assertThat(members.iterator().next().name, is(oliver.name));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating_repositories">7.3. Creating repositories</h3>
<div class="paragraph">
<p>The <code>Repository</code> instances are created through Spring and can be auto-wired into your Spring beans as required.
In previous versions, it was possible to create repositories using <code>Neo4jTemplate</code> but this is no longer possible
as of SDN 4..</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Using basic GraphRepository methods</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface PersonRepository extends GraphRepository&lt;Person&gt; {}

public class MySpringBean {
   @Autowired
   private PersonRepository repo;
   ...
}

// then you can use the repository as you would any other object
Person michael = repo.save(new Person("Michael", 36));

Person dave = repo.findOne(123);

Long numberOfPeople = repo.count();

EndResult&lt;Person&gt; devs = graphRepository.findAllByProperty("occupation", "developer");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The recommended way of providing repositories is to define a repository interface per domain class. The undelying Spring
repository infrastructure will automatically detect these repositories, along with additional implementation classes,
and create an injectable repository implementation to be used in services or other spring beans.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Example Spring configuration bean</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan({"com.example.sdn"})
@EnableNeo4jRepositories("com.example.sdn.repo")
@EnableTransactionManagement
public class PersistenceContext {

   @Bean
   public SessionFactory getSessionFactory() {
      return new SessionFactory("com.example.sdn.domain");
   }
   // more bean definition methods here
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_conversion">8. Conversion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The object-graph mapping framework on which Spring Data Neo4j is built provides support for default and bespoke type
conversions, which allow you to configure how certain data types are mapped to nodes or relationships in Neo4j.</p>
</div>
<div class="sect2">
<h3 id="reference_programming-model_conversion-built_in">8.1. Built-In Type Conversions</h3>
<div class="paragraph">
<p>By default, Spring Data Neo4j will automatically perform the following type conversions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code> to a String in the ISO 8601 format: "yyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSXXX"</p>
</li>
<li>
<p><code>java.math.BigInteger</code> to a String property</p>
</li>
<li>
<p><code>java.math.BigDecimal</code> to a String property</p>
</li>
<li>
<p>binary data (as byte[] or Byte[]) to base-64 String</p>
</li>
<li>
<p><code>java.lang.Enum</code> types using the enum&#8217;s <code>name()</code> method and <code>Enum.valueOf()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two Date converters are provided "out of the box"</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>@DateString</p>
</li>
<li>
<p>@DateLong</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, SDN will use the @DateString converter as described above. However if you want to use a different date
format, you can annotate your entity attribute accordingly:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Example of user-defined date format</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">---
public class MyEntity {</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @DateString("yy-MM-dd")
    private Date entityDate;
}
---
===</pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you want to store Dates as long values, use the @DateLong annotation:</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">---
public class MyEntity {</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    @DateLong
    private Date entityDate;
}
---
===</pre>
</div>
</div>
<div class="paragraph">
<p>Collections of primitive or convertible values are also automatically mapped by converting them to arrays of their type
or strings respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="reference_programming-model_conversion-custom">8.2. Custom Type Conversion</h3>
<div class="paragraph">
<p>In order to define bespoke type conversions for particular members, you can annotate a field or method with <code>@Convert</code>
to specify an implementation of <code>org.neo4j.ogm.typeconversion.AttributeConverter</code> to use.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Example of custom type converter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MoneyConverter implements AttributeConverter&lt;DecimalCurrencyAmount, Integer&gt; {

   @Override
   public Integer toGraphProperty(DecimalCurrencyAmount value) {
       return value.getFullUnits() * 100 + value.getSubUnits();
   }

   @Override
   public DecimalCurrencyAmount toEntityAttribute(Integer value) {
       return new DecimalCurrencyAmount(value / 100, value % 100);
   }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You could then apply this to your class as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Invoice {

   @Convert(MoneyConverter.class)
   private DecimalCurrencyAmount value;
   ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reference_programming-model_mapresult">8.3. Mapping Query Results</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This feature isn&#8217;t supported as of SDN 4 Milestone 1
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For queries executed via <code>@Query</code> repository methods, it&#8217;s possible to specify a conversion of complex query results to POJOs. These result objects are then populated with the query result data and can be serialized and sent to a different part of the applicaton, e.g. a frontend-ui.</p>
</div>
<div class="paragraph">
<p>Use a class annotated with <code>@QueryResult</code> as the method return type and SDN will apply the same simple mapping strategy as it does for normal entities.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Example of query result mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface MovieRepository extends GraphRepository&lt;Movie&gt; {

    @Query("MATCH (movie:Movie)-[r:RATING]-&gt;(), (movie)&lt;-[:ACTS_IN]-(actor:Actor) " +
           "WHERE movie.id={0} " +
           "RETURN movie, COLLECT(actor) AS 'cast', AVG(r.stars) AS 'averageRating'")
    MovieData getMovieData(String movieId);

    @QueryResult
    public class MovieData {
        Movie movie;
        Double averageRating;
        Collection&lt;Actor&gt; cast;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_transactions">9. Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Neo4j is a transactional database, only allowing modifications to be performed within transaction boundaries. Reading data does however not require transactions. Spring Data Neo4j integrates nicely with both the declarative transaction support with <code>@Transactional</code> as well as the manual transaction handling with <code>TransactionTemplate</code>. It also supports the rollback mechanisms of the Spring Testing library.</p>
</div>
<div class="paragraph">
<p>As of version 4.0, the classes used to perform transaction management have been rewritten.  Instead of using <code>SpringTransactionManager</code> provided by the Neo4j kernel alongside Spring&#8217;s <code>JtaTransactionManager</code>, the transaction management is performed by <code>Neo4jTransactionManager</code>, which implements Spring&#8217;s <code>PlatformTransactionManager</code>.
This <code>Neo4jTransactionManager</code> is based on an OGM <code>Session</code>, on which the <code>beginTransaction()</code> method gets called, and this in turn delegates onto the underlying OGM&#8217;s <code>TransactionManager</code> implementation.</p>
</div>
<div class="paragraph">
<p>The <code>Neo4jConfiguration</code> Spring configuration bean will create an instance of this <code>Neo4jTransactionManager</code> for use in Spring Data Neo4j.  It is made available under the name "transactionManager" in the Spring application context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Neither XML-based configuration nor multi-resource transactions are supported in SDN 4 M1
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For scenarios with multiple transactional resources there are two options. The first option is to have Neo4j participate in the externally-configured transaction manager using the Spring support in Neo4j by enabling the configuration parameter for your graph database. Neo4j will then use Spring&#8217;s transaction manager instead of its own.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Neo4j Spring integration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;context:annotation-config /&gt;
&lt;context:spring-configured/&gt;

&lt;bean id="transactionManager"
	         class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;property name="transactionManager"&gt;
        &lt;bean id="jotm" class="org.springframework.data.neo4j.transaction.JotmFactoryBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="graphDatabaseService" class="org.neo4j.kernel.EmbeddedGraphDatabase"
	   destroy-method="shutdown"&gt;
    &lt;constructor-arg value="target/test-db"/&gt;
    &lt;constructor-arg&gt;
        &lt;map&gt;
            &lt;entry key="tx_manager_impl" value="spring-jta"/&gt;
        &lt;/map&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;tx:annotation-driven mode="aspectj" transaction-manager="transactionManager"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure a custom XA transaction manager (e.g. Atomikos, JOTM, App-Server-TM) to be used with Neo4j and the other resources. For a bit less secure but fast 1-phase-commit-best-effort, use <code>ChainedTransactionManager</code>, which comes bundled with Spring Data Neo4j. It takes a list of transaction managers as constructor params and will handle them in order for transaction start and commit (or rollback) in the reverse order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
As of Neo4j 2.2, there is no XA transaction participation support
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 20. ChainedTransactionManager example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jpaTransactionManager"
        class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;
&lt;bean id="jtaTransactionManager"
        class="org.springframework.data.neo4j.config.JtaTransactionManagerFactoryBean"&gt;
    &lt;constructor-arg ref="graphDatabaseService"/&gt;
&lt;/bean&gt;
&lt;bean id="transactionManager"
        class="org.springframework.data.neo4j.transaction.ChainedTransactionManager"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;ref bean="jpaTransactionManager"/&gt;
            &lt;ref bean="jtaTransactionManager"/&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;tx:annotation-driven mode="aspectj" transaction-manager="transactionManager"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_lifecycle">10. Entity Attachment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In previous versions of Spring Data Neo4j, entities could be "attached" or "detached" depending on whether or not they were enhanced by AspectJ and actively managed by the framework. As of SDN 4, this is no longer the case and the AspectJ involvement has completely gone away.</p>
</div>
<div class="paragraph">
<p>The motivation for removing this was to achieve greater simplicity.  AspectJ-enhanced methods can provide a way to right neat, object-oriented code, but often it can be confusing to know whether an entity is managed or not, and the way in which cascading worked from "magic" methods like <code>entity.persist()</code> often caused confusion.  The new method is much simpler.</p>
</div>
<div class="sect2">
<h3 id="reference_programming-model_lifecycle_persistence">10.1. Persisting Entities</h3>
<div class="paragraph">
<p>From version 4 onwards, the entity persistence is all performed through the <code>save()</code> method on the <code>Session</code> object.  This method is normally invoked indirectly via a Spring repository or <code>Neo4jTemplate</code>, but will work just as well if invoked directly if you&#8217;re working with the <code>Session</code> in its raw form.</p>
</div>
<div class="paragraph">
<p>Under the bonnet, the implementation of <code>Session</code> has access to the <code>MappingContext</code> that keeps track of the data that has been loaded from Neo4j during the lifetime of the session.  Upon invocation of <code>save()</code> with an entity, it checks the given object graph for changes compared with the data that was loaded from the database.  The differences are used to construct a Cypher query that persists the deltas to Neo4j before repopulating it&#8217;s state based on the response from the database server.</p>
</div>
<div class="paragraph">
<p>One thing that hasn&#8217;t changed in version 4 is the fact that all entities returned by library functions are initially in an attached state, and those created with the <code>new</code> keyword aren&#8217;t.  However, there&#8217;s no longer any attachment or detachment that goes on depending on where certain code is executed, because entities aren&#8217;t managed with AspectJ enhancements.  Therefore calling <code>save()</code> is always required in order to persist your changes back to Neo4j.</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. Persisting entities</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public class Person {
   private String name;
   public Person(String name) {
      this.name = name;
   }
}

// Store Michael in the database.
Person p = new Person("Michael");
personRepository.save(p);
// or alternatively
neo4jTemplate.save(p);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reference_programming-model_detached_relating">10.2. Save Depth</h3>
<div class="paragraph">
<p>As mentioned previously, <code>save(entity)</code> is overloaded as <code>save(entity, depth)</code>, where depth dictates the number of related entities to save starting from the given entity.  A depth of 0 will persist only the properties of the specified entity to the database, and a depth of -1 will persist everything in the object graph rooted at the given entity.</p>
</div>
<div class="paragraph">
<p>Specifying the save depth is handy when it comes to dealing with complex collections, that could potentially be very expensive to load.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you&#8217;re using this overloaded method rather than the repositories, it&#8217;s <strong>strongly</strong> recommended to use depth consistently between load and save invocations.  If you don&#8217;t then you may unexpectedly see relationships deleted or updates not persisting as you expect.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 22. Relationship save cascading</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
class Movie {
    private Actor topActor;
    public void setTopActor(Actor actor) {
        topActor = actor;
    }
}

@NodeEntity
class Actor {
}

Movie movie = new Movie();
Actor actor = new Actor();

movie.setTopActor(actor);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Neither the actor nor the movie has been assigned a node in the graph. If we were to call <code>repository.save(movie)</code>, then Spring Data Neo4j would first create a node for the movie. It would then note that there is a relationship to an actor, so it would save the actor in a cascading fashion.  Once the actor has been persisted, it will create the relationship from the movie to the actor. All of this will be done atomically in one transaction.</p>
</div>
<div class="paragraph">
<p>The important thing to note here is that if <code>repository.save(actor)</code> is called instead, then only the actor will be persisted. The reason for this is that the actor entity knows nothing about the movie entity - it is the movie entity that has the reference to the actor. Also note that this behaviour is not dependent on any configured relationship direction on the annotations. It is a matter of Java references and is not related to the data model in the database.</p>
</div>
<div class="paragraph">
<p>If the relationships form a cycle, then the entities will first of all be assigned a node in the database, and then the relationships will be created. The cascading is however only propagated to related entity fields that have been modified.</p>
</div>
<div class="paragraph">
<p>In the following example, the actor and the movie are both attached entites, having both been previously persisted to the graph:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Cascade for modified fields</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">actor.setName("Billy Bob");
movieRepository.save(movie);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, even though the movie has a reference to the actor, the name change on the actor will not be persisted by the call to <code>movie.persist()</code>. The reason for this is, as mentioned above, that cascading will only be done for fields that have been modified. Since the <code>movie.topActor</code> field has not been modified, it will not cascade the persist operation to the actor.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_typerepresentationstrategy">11. Entity Type Representation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of Spring Data Neo4j 4, type representation has been greatly simplified to the point that there is just one strategy.
The <code>TypeRepresentationStrategy</code> has disappeared and a single label-based model is all that is supported.</p>
</div>
<div class="paragraph">
<p>For <code>@NodeEntity</code> classes, the simple names of the class and each of its parent classes (excluding <code>java.lang.Object</code>)
is written as a node label.  This node label is used in Cypher queries generated by the OGM to find objects of a particular type,
and by labelling using superclasses as well it becomes possible to retrieve collections of entities as abstract super types.</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Example domain model and labels</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
public abstract class DomainObject {
   @GraphId
   protected Long id;
}

public class Person extends DomainObject {
   ...
}

public class Lady extends Person {
   ...
}

public class Gentleman extends Person {
   ...
}

// creates a node with labels Gentleman:Person:DomainObject
repository.save(new Gentleman());

// retrieve all ladies and gentlemen
Collection&lt;Person&gt; people = repository.loadAll(Person.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The label applied to a node in the database can be configured by setting the value of the <code>label</code> property in the
<code>@NodeEntity</code> annotation.</p>
</div>
<div class="paragraph">
<p>For <code>@RelationshipEntity</code> classes, the simple name of the class is used to derive the relationship type to use,
although it&#8217;s converted into SNAKE_CASE to honour the typical naming conventions of Neo4j relationships.  Much like node
entities, you can configure the relationship type to use by setting the <code>type</code> property in the <code>@RelationshipEntity</code>
annotation.</p>
</div>
<div class="sect2">
<h3 id="type_aliases">11.1. Type Aliases</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
As of SDN 4 milestone 1, <code>@TypeAlias</code> is not currently supported
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As some type information is also stored in labels, node/relationship-properties and/or indexes it might amount to a
substantial amount of data in the graph. It is possible to use an <code>@TypeAlias("name")</code> annotation on nodes and
relationships to have a short constant name for each type which is (unlike the default approach) renaming-refactoring-safe.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_programming_model_validation">12. Bean Validation (JSR-303)</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
As of Spring Data Neo4j 4 milestone 1, Java standards validation is not supported
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data Neo4j supports property-based validation as defined by JSR-303.  When a property is changed and persisted, it is checked against the annotated constraints, such as <code>@Min</code>, <code>@Max</code> and <code>@Size</code>.  Validation errors cause a <code>ValidationException</code> to be thrown. The validation support that comes with Spring is used for evaluating the constraints. To use this feature, a validator has to be registered with the <code>Neo4jTemplate</code>, which is done automatically by the <code>Neo4jConfiguration</code> if one is present in the Spring Config.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Bean validation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
class Person {
    @Size(min = 3, max = 20)
    String name;

    @Min(0)
    @Max(100)
    int age;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The validation supports needs the bean validation API and a reference implementation configured. Right now this is the Hibernate Validator by default (which is not integrated with Hibernate ORM). The maven dependency is:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Validation setup</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
  &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
  &lt;version&gt;4.2.0.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference_performance">Performance considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like with any other object mapping framework, the domain entities that are created, read, or persisted potentially
represent only a small fraction of the data stored in the database. This is the set needed for a certain use-case to
be displayed, edited or processed in a low throughput fashion. The main advantages of using an object mapper in this
case are the ease of use of real domain objects in your business logic and also the integration with existing frameworks
and libraries that expect Java POJOs as input or create them as results.</p>
</div>
<div class="paragraph">
<p>Although adding layers of abstraction is a common pattern in software development, each of these layers generally adds
overhead and performance penalties. This chapter discusses the performance implications of using Spring Data Neo4j.</p>
</div>
<div class="sect2">
<h3 id="a_little_history">A little history</h3>
<div class="paragraph">
<p>Previous versions of Neo4j were not designed with a major focus on performance. being very much geared to applications
using an embedded instance of Neo4j, or where the Neo4j server was available via a managed extension.</p>
</div>
<div class="paragraph">
<p>Consequently they were not really suited to running with remote instances, and in fact, until the advent
of Cypher over HTTP, this wasn&#8217;t even technically possible. Furthermore, attempts to do so very often resulted in
very "chatty" applications where multiple requests needed to be made to fully hydrate a single object. These
observations should not be seen as criticisms, because it was all that was possible at the time.</p>
</div>
<div class="paragraph">
<p>Since then however Neo4j has moved on, and now, so has Spring Data Neo4j</p>
</div>
</div>
<div class="sect2">
<h3 id="focus_on_performance">Focus on performance</h3>
<div class="paragraph">
<p>The new version of SDN has been rebuilt from the ground up, on the understanding that the majority of users want to
run application servers that connect to remote database instances, and that they will therefore need to communicate
"over the wire". Neo4j provides the capability to do this now with its powerful Cypher language, which is exposed
over HTTP directly from the server.</p>
</div>
<div class="paragraph">
<p>What we have attempted to do is to ensure that, as much as possible, we don&#8217;t overload that communication. This is
important for two reasons. Firstly, every network interaction involves an overhead, and the more data it contains, the
greater the impact on the response times of the application. Secondly, network requests containing redundant operations
(such as updaing an object which hasn&#8217;t changed) simply waste CPU cycles on the server, and again impact on the overall
response times of the application. We have approached this problem in a number of ways:</p>
</div>
<div class="sect3">
<h4 id="variable_depth_persistence">Variable-depth persistence</h4>
<div class="paragraph">
<p>You can now tailor your persistence requests according to the characteristics of the portions of your graph
you want to work with. This means you can choose to make deeper or shallower fetches based on fine tuning
the types and amounts of data you want versus your available bandwidth and memory constraints.</p>
</div>
<div class="paragraph">
<p>If you know that you aren&#8217;t going to need an object&#8217;s related objects, you can choose not to fetch them by setting
the depth to 0. Alternatively if you know that you will always want to a person&#8217;s complete set of friends-of-friends,
you can set the depth to 2.</p>
</div>
</div>
<div class="sect3">
<h4 id="smart_object_mapping">Smart object-mapping</h4>
<div class="paragraph">
<p>SDN 4 introduces smart object-mapping. This means that all other things being equal, it is possible to reliably detect
which nodes and relationships needs to be changed in the database, and which don&#8217;t. Knowing what needs to be changed means
we don&#8217;t need to flood Neo4j with requests to update objects that don&#8217;t require changing, or create relationships
that already exist. We can minimise the amount of data we send across the wire as a result, which results in a faster
network interaction, and fewer CPU cycles consumed on the server.</p>
</div>
</div>
<div class="sect3">
<h4 id="user_definable_session_lifetime">User-definable Session lifetime</h4>
<div class="paragraph">
<p>Supporting the smart object-mapping capability is the Neo4jSession. This object can be declared with
different lifetimes, depending on the requirements of your application. For web-based applications, you might choose
between HTTP Request-scoped lifetime or HTTP Session-scoped lifetimes. For a standalone application, you may choose
to maintain a single session for the entire lifetime of the application.</p>
</div>
<div class="paragraph">
<p>The advantage of longer-running sessions is that you will be able to make more efficient requests to the database at the
expense of the additional memory associated with the session. The advantage of shorter sessions is they
impose almost no overhead on memory, but will result in less efficient requests to Neo4j when saving data.</p>
</div>
<div class="paragraph">
<p>It is also possible to manage your session lifetimes in code. For example, associated with single <code>fetch-update-save</code> cycle
or unit of work.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="migration" class="sect0">Migrating from previous versions of Spring Data Neo4j</h1>
<div class="sect2">
<h3 id="package_changes">1.1. Package changes</h3>
<div class="paragraph">
<p>Because the Neo4j Object Graph Mapper can be used independently of the Spring wrappers, the core annotations have been
moved out of the spring framework packages:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>org.springframework.data.neo4j.annotation</code> &#8594; <code>org.neo4j.ogm.annotation</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The exception to this is the <code>@Query</code> which is not supported as an annotation in the core OGM.</p>
</div>
</div>
<div class="sect2">
<h3 id="annotation_changes">1.2. Annotation changes</h3>
<div class="paragraph">
<p>There have been some changes to the annotations that were used in previous versions of Spring Data Neo4j.
Wherever possible we have tried to maintain the previous annotations verbatim, but in a few cases this has not been
possible, usually for technical reasons but sometimes for aesthetic ones. Our goal has been to minimise the number
of annotations you need to use as well as trying to make them more self-explanatory. The following annotations
have been changed.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@RelatedTo</code> &#8594; <code>@Relationship</code></p>
</li>
<li>
<p><code>@RelatedToVia</code> &#8594; <code>@Relationship</code></p>
</li>
<li>
<p><code>@GraphProperty</code> &#8594; <code>@Property</code></p>
</li>
<li>
<p>Relationship <code>Direction.BOTH</code> &#8594; <code>Relationship.UNDIRECTED</code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="custom_converters">1.3. Custom Type Conversion</h3>
<div class="paragraph">
<p>SDN 4 provides automatic type conversion for the obvious candidates: byte[] and Byte[] arrays, Dates, BigDecimal and
BigInteger types. In order to define bespoke type conversions for particular entity attribute, you can annotate a
field or method with <code>@Convert</code> to specify your own implementation of <code>org.neo4j.ogm.typeconversion.AttributeConverter</code>.</p>
</div>
<div class="paragraph">
<p>You can find out more about type conversions here: <a href="#reference_programming-model_conversion-custom">Custom Type Conversion</a></p>
</div>
</div>
<div class="sect2">
<h3 id="obsolete_annotations">1.4. Obsolete annotations</h3>
<div class="paragraph">
<p>The following annotations are no longer used, either because they are no longer needed, cannot be supported via Cypher, or
simply because they are a bad idea.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>@GraphTraversal</p>
</li>
<li>
<p>@RelatedToVia</p>
</li>
<li>
<p>@Index</p>
</li>
<li>
<p>@TypeAlias</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="features_no_longer_supported">1.5. Features no longer supported</h3>
<div class="paragraph">
<p>Some features of the previous annotations have been dropped.</p>
</div>
<div class="sect3">
<h4 id="overriding_property_types">1.5.1. Overriding @Property types</h4>
<div class="paragraph">
<p>Support for overriding property types via arguments to @Property has been dropped. If your attribute requires
a non-default conversion to and from a database property, you can use a <a href="#custom_converters">Custom Converter</a> instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="relationship_code_enforcetargettype_code">1.5.2. @Relationship <code>enforceTargetType</code></h4>
<div class="paragraph">
<p>In previous versions of Spring Data Neo4j, you would have to add an <code>enforceTargetType</code> attribute into every clashing
<code>@Relationship</code> annotation.  Thanks to changes in the underlying object-graph mapping mechanism, this is no longer
necessary and this now works just fine.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Clashing Relationship Types</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NodeEntity
class Person {
    @Relationship(type="OWNS")
    private Car car;

    @Relationship(type="OWNS")
    private Pet pet;
...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cross_store_persistence">1.5.3. Cross-store persistence</h4>
<div class="paragraph">
<p>Neo4j is dropping XA support and therefore SDN 4 does not provide any capability for cross-store persistence</p>
</div>
</div>
<div class="sect3">
<h4 id="query_dsl_with_neo4jtemplate">1.5.4. Query DSL with Neo4jTemplate</h4>
<div class="paragraph">
<p>Previous  versions of SDN allowed you to use a DSL to generate Cypher queries. There are many different DSL
libraries available and you&#8217;re free to use which of these - or none - that you want. With Cypher changing on a regular
basis, avoiding a DSL implementation in SDN means less ongoing maintenance and less likelihood of your code
being incompatible with future versions of Neo4j.</p>
</div>
</div>
<div class="sect3">
<h4 id="graph_traversal_and_node_relationship_manipulation_with_neo4jtemplate">1.5.5. Graph traversal and node/relationship manipulation with Neo4jTemplate</h4>
<div class="paragraph">
<p>These features cannot be supported by Cypher and have therefore been dropped from Neo4jTemplate.</p>
</div>
</div>
<div class="sect3">
<h4 id="typerepresentationstrategy">1.5.6. TypeRepresentationStrategy</h4>
<div class="paragraph">
<p>SDN 4 replaces the existing TypeRepresentionStrategy configuration with a straightforwad convention based on simple class-names
or entities using <code>@NodeEntity(label=&#8230;&#8203;)</code></p>
</div>
<div class="paragraph">
<p>Please refer to <a href="#reference_programming_model_typerepresentationstrategy">Entity Type Representation</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="aspectj_support_dropped">1.5.7. AspectJ support dropped</h4>
<div class="paragraph">
<p>Due to numerous problems reported by users in earlier versions of SDN, support for Aspect J based persistence has
been removed from SDN 4.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="features_not_yet_included_in_milestone_1_but_that_are_on_the_roadmap">1.6. Features not yet included in Milestone 1 but that are on the Roadmap</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Geospatial queries</p>
</li>
<li>
<p>@QueryResult</p>
</li>
</ol>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version {version}<br>
Last updated 2015-02-05 17:56:16 WET
</div>
</div>
</body>
</html>